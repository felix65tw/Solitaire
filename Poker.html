<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>經典接龍 (手機適配版) - 三張翻牌模式</title>
    <style>
        /* CSS 變數定義，方便全域調整樣式 */
        :root {
            --bg-color: #35654d; /* 遊戲背景顏色 */
            --card-width: 13vw; /* 卡片預設寬度 (視窗寬度百分比) */
            --card-height: 18.2vw; /* 卡片預設高度 (視窗寬度百分比) */
            --max-w: 100px; /* 卡片最大寬度 */
            --max-h: 140px; /* 卡片最大高度 */
            --gap: 2vw; /* 卡片間距 */
        }

        /* 全域樣式設定 */
        body {
            background-color: var(--bg-color); /* 使用CSS變數設定背景色 */
            margin: 0;
            overflow: hidden; /* 隱藏滾動條 */
            user-select: none; /* 禁止文字選取 */
            font-family: sans-serif; /* 字型設定 */
            -webkit-tap-highlight-color: transparent; /* 移除移動端點擊高亮 */
            touch-action: manipulation; /* 改善觸控響應 */
        }

        /* 工具欄樣式 */
        .toolbar {
            height: 50px; /* 工具欄高度 */
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px; /* 手機上減少padding */
            color: white;
            background: rgba(0,0,0,0.2); /* 半透明黑色背景 */
        }
        
        /* 工具欄左側區塊 */
        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 15px; /* 元素間距 */
        }
        
        /* 時間與步數顯示 - 修改為固定寬度 */
        .time-moves-display {
            font-size: 14px;
            font-weight: bold;
            color: white;
            padding: 2px 8px;
            background: rgba(0,0,0,0.3); /* 半透明背景 */
            border-radius: 10px; /* 圓角 */
            min-width: 120px; /* 固定寬度，容納4位數 */
            text-align: center;
            font-variant-numeric: tabular-nums; /* 等寬數字 */
        }
        
        /* 分數顯示 - 修改為固定寬度 */
        .score-display {
            font-size: 14px;
            font-weight: bold;
            color: #FFD700; /* 金色文字 */
            padding: 2px 8px;
            background: rgba(0,0,0,0.3); /* 半透明背景 */
            border-radius: 10px; /* 圓角 */
            min-width: 80px; /* 固定寬度，容納4位數 */
            text-align: center;
            font-variant-numeric: tabular-nums; /* 等寬數字 */
        }
        
        /* 模式切換按鈕容器 - 隱藏，移動到設定中 */
        .mode-toggle-container,
        .hand-toggle-container {
            display: none; /* 隱藏，移動到設定中 */
        }
        
        /* 工具欄按鈕區塊 */
        .toolbar-buttons {
            display: flex;
            gap: 5px; /* 手機上按鈕間距小一點 */
        }
        
        /* 按鈕基礎樣式 */
        button {
            background: white;
            border: none;
            padding: 6px 10px; /* 手機上按鈕小一點 */
            border-radius: 4px; /* 圓角 */
            font-weight: bold;
            cursor: pointer; /* 游標手形 */
            font-size: 12px; /* 手機上字體小一點 */
            white-space: nowrap; /* 不換行 */
        }
        
        /* 設定按鈕特殊樣式 */
        #settings-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
            color: white;
        }
        
        /* 魔法按鈕特殊樣式 */
        #magic-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        #magic-btn:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }
        
        #magic-btn:disabled {
            background: #cccccc;
            color: #666;
            border: 2px solid #999;
            box-shadow: none;
        }
        
        /* 按鈕懸停效果 */
        button:hover {
            background: #f0f0f0;
        }
        
        /* 禁用按鈕樣式 */
        button:disabled {
            background: #cccccc;
            cursor: not-allowed; /* 禁用游標 */
        }
        
        /* 訊息提示框 */
        #message {
            position: fixed; /* 固定定位 */
            top: 60px;
            left: 50%;
            transform: translateX(-50%); /* 水平居中 */
            background: rgba(0,0,0,0.8); /* 半透明黑色背景 */
            color: white;
            padding: 10px 20px;
            border-radius: 5px; /* 圓角 */
            z-index: 10000; /* 確保在最上層 */
            display: none; /* 預設隱藏 */
            font-size: 14px;
            max-width: 90%; /* 最大寬度 */
            text-align: center; /* 文字居中 */
        }

        /* 遊戲主區域 */
        #game-board {
            position: relative; /* 相對定位 */
            width: 100vw; /* 全視窗寬度 */
            height: calc(100vh - 50px); /* 減去工具欄高度 */
            max-width: 800px; /* 最大寬度限制 */
            margin: 0 auto; /* 水平居中 */
            margin-top: 5px; /* 手機上減少上邊距 */
            overflow: hidden; /* 防止溢出 */
        }

        /* 卡片位置槽位 */
        .slot {
            position: absolute; /* 絕對定位 */
            width: var(--card-width); /* 使用CSS變數設定寬度 */
            height: var(--card-height); /* 使用CSS變數設定高度 */
            max-width: var(--max-w); /* 最大寬度限制 */
            max-height: var(--max-h); /* 最大高度限制 */
            border: 2px solid rgba(255,255,255,0.2); /* 半透明邊框 */
            border-radius: 8px; /* 圓角 */
            box-sizing: border-box; /* 盒模型設定 */
        }

        /* 卡片基礎樣式 */
        .card {
            position: absolute; /* 絕對定位 */
            width: var(--card-width); /* 使用CSS變數設定寬度 */
            height: var(--card-height); /* 使用CSS變數設定高度 */
            max-width: var(--max-w); /* 最大寬度限制 */
            max-height: var(--max-h); /* 卡片最大高度限制 */
            background-color: white; /* 白色背景 */
            border-radius: 6px; /* 圓角 */
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4); /* 陰影效果 */
            display: flex;
            justify-content: center; /* 水平居中 */
            align-items: center; /* 垂直居中 */
            z-index: 10; /* 圖層順序 */
            cursor: pointer; /* 游標手形 */
            box-sizing: border-box; /* 盒模型設定 */
            transition: box-shadow 0.2s; /* 陰影過渡效果 */
            -webkit-user-drag: none; /* 防止拖曳圖片 */
        }

        /* 用於自動移動時的飛行卡片 */
        .flying-card {
            position: fixed; /* 固定定位 */
            z-index: 99999; /* 最高圖層 */
            pointer-events: none; /* 禁止觸發事件 */
            transition: all 0.3s ease-in-out; /* 過渡動畫 */
        }

        /* 卡片面 */
        .card-face {
            width: 100%;
            height: 100%;
            position: relative; /* 相對定位 */
            pointer-events: none; /* 禁止觸發事件 */
        }

        /* 左上角數字 */
        .card-num { 
            font-size: 1.8rem; 
            font-weight: 800; 
            line-height: 1;
            position: absolute;
            top: 4px; /* 減少上邊距 */
            left: 4px; /* 減少左邊距 */
        }
        
        /* 右上角花色 */
        .card-suit-top { 
            font-size: 1.8rem; 
            line-height: 1; 
            position: absolute;
            top: 4px; /* 減少上邊距 */
            right: 4px; /* 減少右邊距 */
        }
        
        /* 卡片中間的大花色 */
        .card-center-suit {
            position: absolute;
            top: 62%; /* 原本是 50%，改成 62% 往下移 */
            left: 50%;
            transform: translate(-50%, -50%); /* 居中對齊 */
            font-size: 4rem;
            font-weight: normal;
        }
        
        /* 紅色花色 */
        .red { color: #d32f2f; }
        /* 黑色花色 */
        .black { color: #212121; }

        /* 卡片背面樣式 */
        .back {
            background: repeating-linear-gradient( /* 重複線性漸變 */
                45deg, /* 45度角 */
                #1565c0, /* 顏色1 */
                #1565c0 10px, /* 顏色1結束位置 */
                #0d47a1 10px, /* 顏色2開始位置 */
                #0d47a1 20px /* 顏色2結束位置 */
            );
            border: 2px solid #fff; /* 白色邊框 */
        }
        
        /* 牌堆卡片上的剩餘數量顯示 */
        .card-count {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            z-index: 2;
        }
        
        /* 隱藏剩餘數量顯示 */
        .card-count.hidden {
            display: none;
        }

        /* 拖曳中的卡片 */
        .dragging-card {
            position: fixed; /* 固定定位 */
            z-index: 9999; /* 高圖層 */
            pointer-events: none; /* 禁止觸發事件 */
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5); /* 更明顯的陰影 */
            opacity: 0.9; /* 半透明 */
        }

        /* 重新整理按鈕 */
        .refresh-btn {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; color: rgba(255,255,255,0.5);
            cursor: pointer;
        }

        /* 高光效果：增加 pointer-events: none 防止擋住點擊 */
        .highlight {
            animation: yellowPulse 0.8s infinite alternate; /* 動畫效果 */
            box-shadow: 0 0 0 4px #FFEB3B, 0 0 20px 8px #FFEB3B !important;
            border: 2px solid #FFEB3B !important;
            z-index: 1000;
            pointer-events: none; /* 關鍵修復：讓點擊穿透高光框 */
        }

        /* 目標高光效果 */
        .target-highlight {
            animation: targetPulse 0.8s infinite alternate;
            box-shadow: 0 0 0 4px #4CAF50, 0 0 20px 8px #4CAF50 !important;
            border: 2px solid #4CAF50 !important;
            z-index: 999;
            pointer-events: none; /* 關鍵修復 */
        }

        /* 黃色脈衝動畫 */
        @keyframes yellowPulse {
            0% { box-shadow: 0 0 0 4px #FFEB3B, 0 0 20px 8px #FFEB3B !important; transform: scale(1.02); }
            100% { box-shadow: 0 0 0 6px #FFEB3B, 0 0 30px 12px #FFEB3B !important; transform: scale(1.05); }
        }

        /* 綠色脈衝動畫 */
        @keyframes targetPulse {
            0% { box-shadow: 0 0 0 4px #4CAF50, 0 0 20px 8px #4CAF50 !important; transform: scale(1.02); }
            100% { box-shadow: 0 0 0 6px #4CAF50, 0 0 30px 12px #4CAF50 !important; transform: scale(1.05); }
        }

        /* 金光閃閃動畫 - 魔法按鈕專用 (加強版) */
        .golden-glow {
            animation: goldenPulse 0.5s infinite alternate;
            box-shadow: 
                0 0 30px #FFD700, 
                0 0 60px #FFD700, 
                0 0 90px #FFD700,
                0 0 120px #FFD700,
                0 0 150px #FFD700 !important;
            border: 4px solid #FFD700 !important;
            z-index: 99999;
            filter: brightness(1.5);
        }

        @keyframes goldenPulse {
            0% { 
                box-shadow: 
                    0 0 20px #FFD700, 
                    0 0 40px #FFD700, 
                    0 0 60px #FFD700,
                    0 0 80px #FFD700 !important; 
                transform: scale(1.05);
                filter: brightness(1.2);
            }
            100% { 
                box-shadow: 
                    0 0 40px #FFD700, 
                    0 0 80px #FFD700, 
                    0 0 120px #FFD700,
                    0 0 160px #FFD700 !important; 
                transform: scale(1.15);
                filter: brightness(1.8);
            }
        }

        /* 抖動動畫 */
        .shake {
            animation: shake 0.4s ease-in-out;
        }

        /* 抖動動畫關鍵影格 */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            16% { transform: translateX(-6px); }
            33% { transform: translateX(6px); }
            50% { transform: translateX(-6px); }
            66% { transform: translateX(6px); }
            83% { transform: translateX(-6px); }
        }

        /* 翻牌動畫卡片 */
        .draw-animation-card {
            position: fixed;
            z-index: 99998;
            pointer-events: none;
            transition: all 0.4s ease-in-out;
            transform-origin: center;
            background-color: white !important; /* 確保動畫卡片背景為白色 */
        }
        
        /* 魔法動畫卡片 */
        .magic-animation-card {
            position: fixed;
            z-index: 99997;
            pointer-events: none;
            transition: all 0.5s ease-in-out;
            transform-origin: center;
            background-color: white !important;
            border: 2px solid #667eea;
            box-shadow: 0 0 20px #667eea !important;
        }
        
        /* 手機版功能鍵容器 - 美化版 */
        .mobile-toolbar-container {
            display: none;
            position: fixed; /* 改為固定定位 */
            bottom: 20px; /* 調整位置到頁面底部 */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95); /* 改為半透明白色背景 */
            border-radius: 25px; /* 增加圓角 */
            padding: 12px 20px; /* 增加內邊距 */
            box-shadow: 0 8px 25px rgba(0,0,0,0.15); /* 增加陰影效果 */
            flex-direction: row; /* 橫向排列 */
            gap: 15px; /* 增加間距 */
            flex-wrap: nowrap; /* 防止換行 */
            justify-content: center;
            align-items: center;
            min-width: 280px; /* 最小寬度 */
            max-width: 90%;
            backdrop-filter: blur(10px); /* 毛玻璃效果 */
            border: 1px solid rgba(255, 255, 255, 0.2); /* 邊框 */
        }
        
        /* 手機版功能按鈕美化 */
        .mobile-toolbar-container button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* 漸變背景 */
            color: white;
            border: none;
            border-radius: 50px; /* 橢圓形按鈕 */
            padding: 12px 18px; /* 增加內邊距 */
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); /* 陰影效果 */
            transition: all 0.3s ease;
            min-width: 70px; /* 最小寬度 */
            white-space: nowrap;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* 手機按鈕懸停效果 */
        .mobile-toolbar-container button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }
        
        /* 手機按鈕按下效果 */
        .mobile-toolbar-container button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        /* 手機禁用按鈕樣式 */
        .mobile-toolbar-container button:disabled {
            background: linear-gradient(135deg, #cccccc 0%, #999999 100%);
            color: #666;
            box-shadow: none;
            transform: none;
            cursor: not-allowed;
        }
        
        /* 新牌局對話框樣式 */
        .new-game-dialog,
        .settings-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 100000;
            min-width: 250px;
            text-align: center;
        }
        
        .new-game-dialog h3,
        .settings-dialog h3 {
            margin-top: 0;
            color: #35654d;
            font-size: 18px;
            margin-bottom: 20px;
        }
        
        .new-game-dialog button,
        .settings-dialog button {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .new-game-dialog .new-game-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
            color: white;
        }
        
        .new-game-dialog .restart-game-btn {
            background: linear-gradient(135deg, #2196F3 0%, #0D47A1 100%);
            color: white;
        }
        
        .new-game-dialog .back-btn {
            background: #f5f5f5;
            color: #333;
        }
        
        .new-game-dialog .new-game-btn:hover {
            background: linear-gradient(135deg, #2E7D32 0%, #4CAF50 100%);
        }
        
        .new-game-dialog .restart-game-btn:hover {
            background: linear-gradient(135deg, #0D47A1 0%, #2196F3 100%);
        }
        
        .new-game-dialog .back-btn:hover {
            background: #e0e0e0;
        }
        
        /* 設定選項樣式 */
        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }
        
        .settings-option:last-child {
            border-bottom: none;
        }
        
        .settings-option label {
            font-size: 16px;
            color: #333;
            flex: 1;
            text-align: left;
        }
        
        .settings-toggle {
            display: flex;
            background: rgba(0,0,0,0.1);
            border-radius: 20px;
            padding: 4px;
            gap: 4px;
        }
        
        .settings-option-btn {
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
            border: none;
            background: transparent;
        }
        
        .settings-option-btn.active {
            background: white;
            color: #35654d;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .settings-back-btn {
            background: #f5f5f5;
            color: #333;
            margin-top: 20px;
        }
        
        .settings-back-btn:hover {
            background: #e0e0e0;
        }
        
        /* 對話框遮罩 */
        .dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 99999;
        }
        
        /* 桌面版樣式 - 維持原始文字和花色大小 */
        @media (min-width: 600px) {
            :root {
                --card-width: 80px; /* 桌面版固定寬度 */
                --card-height: 112px; /* 桌面版固定高度 */
                --gap: 15px; /* 桌面版固定間距 */
            }
            
            /* 桌面版保持原始大小 */
            .card-num, .card-suit-top { font-size: 1.8rem; }
            .card-center-suit { font-size: 4rem; }
            
            /* 桌面版數字10保持正常 */
            .card[data-text="10"] .card-num {
                font-size: 1.8rem !important;
                transform: none !important;
                left: 4px !important;
            }
            
            .toolbar {
                padding: 0 20px; /* 桌面版增加padding */
            }
            
            .time-moves-display {
                font-size: 16px; /* 桌面版字體稍大 */
                padding: 4px 12px; /* 桌面版padding稍大 */
            }
            
            .toolbar-buttons {
                gap: 10px; /* 桌面版按鈕間距稍大 */
            }
            
            button {
                padding: 8px 16px; /* 桌面版按鈕稍大 */
                font-size: 14px; /* 桌面版字體稍大 */
            }
            
            .score-display {
                font-size: 16px; /* 桌面版字體稍大 */
                padding: 4px 12px; /* 桌面版padding稍大 */
            }
            
            .new-game-dialog,
            .settings-dialog {
                min-width: 300px;
                padding: 25px;
            }
            
            .new-game-dialog h3,
            .settings-dialog h3 {
                font-size: 20px;
            }
            
            .settings-option label {
                font-size: 16px;
            }
        }

        /* 手機版專用樣式 - 已調整 */
        @media (max-width: 599px) {
            :root {
                --card-width: 12.5vw; /* 卡片寬度 (從11vw增加) */
                --card-height: 17.5vw; /* 卡片高度 (從15.4vw增加) */
                --gap: 1vw; /* 縮小牌間距 (從1.5vw減少) */
            }
            
            /* 顯示手機版功能鍵容器 */
            .mobile-toolbar-container {
                display: flex;
            }
            
            /* 隱藏桌面版工具欄按鈕 */
            .toolbar-buttons {
                display: none;
            }
            
            /* 手機上卡片字體調整 */
            .card-num { 
                font-size: 2.5rem; /* 調整為2.5rem (從3rem減少) */
                font-weight: 800;
                position: absolute;
                top: 0.1px;
                left: 1.3px;
                line-height: 0.8;
            }
            
            /* 特殊處理數字"10" - 只在手機版縮小寬度不縮小高度 */
            .card[data-text="10"] .card-num {
                font-size: 2.5rem; /* 調整字體大小 */
                transform: scaleX(0.75); /* 壓縮寬度為80% */
                transform-origin: left top; /* 從左上角開始縮放 */
                left: 0.8px; /* 調整位置 */
            }
            
            .card-suit-top {
                font-size: 0.8rem;
                position: absolute;
                top: 6px;
                right: 2px;
                line-height: 1;
            }
            
            /* 手機上中間花色調整 */
            .card-center-suit { 
                font-size: 2.2rem; /* 從2.2rem增加到2.5rem */
                position: absolute;
                top: 25px;
                left: 50%;
                transform: translateX(-50%);
                font-weight: normal;
            }
            
            /* 手機上工具欄調整 */
            .toolbar {
                height: 45px; /* 手機版工具欄稍矮 */
                padding: 0 8px; /* 手機版padding稍小 */
            }
            
            .toolbar-left {
                gap: 8px; /* 手機版工具欄左側間距稍小 */
            }
            
            .time-moves-display {
                font-size: 11px; /* 手機版字體稍小 */
                padding: 2px 6px; /* 手機版padding稍小 */
                min-width: 100px; /* 固定寬度，容納4位數 */
            }
            
            .score-display {
                font-size: 11px; /* 手機版字體稍小 */
                padding: 2px 6px; /* 手機版padding稍小 */
                min-width: 65px; /* 固定寬度，容納4位數 */
            }
            
            #game-board {
                height: calc(100vh - 45px); /* 減去工具欄高度 */
                margin-top: 3px; /* 手機版上邊距稍小 */
            }
            
            /* 手機上訊息框調整 */
            #message {
                font-size: 12px; /* 手機版字體稍小 */
                padding: 8px 15px; /* 手機版padding稍小 */
                top: 50px; /* 調整位置 */
                max-width: 95%; /* 最大寬度限制 */
            }
            
            /* 手機版蓋牌上的數字顯示調整 */
            .card-count {
                font-size: 2.0rem; /* 調整蓋牌數字大小 (從2.5rem調整) */
            }
            
            /* 設定對話框手機版調整 */
            .settings-dialog {
                max-width: 90%;
                padding: 15px;
            }
            
            .settings-option {
                margin: 10px 0;
                padding: 8px 0;
            }
            
            .settings-option label {
                font-size: 14px;
            }
            
            .settings-option-btn {
                padding: 4px 8px;
                font-size: 12px;
            }
            
            /* 特別小的手機 */
            @media (max-width: 320px) {
                :root {
                    --card-width: 12vw; /* 稍微調整 */
                    --card-height: 16.8vw; /* 等比例調整 */
                    --gap: 0.8vw; /* 更小的間距 */
                }
                
                .time-moves-display {
                    font-size: 10px; /* 更小的字體 */
                    min-width: 90px; /* 固定寬度，容納4位數 */
                }
                
                .score-display {
                    font-size: 10px; /* 更小的字體 */
                    min-width: 55px; /* 固定寬度，容納4位數 */
                }
                
                /* 在特別小的屏幕上進一步調整卡片字體 */
                .card-num { 
                    font-size: 2.2rem; /* 比2.5rem稍小一點 */
                    top: 1.3px; /* 保持1.3px邊距 */
                    left: 1.3px; /* 保持1.3px邊距 */
                }
                
                /* 特別小的屏幕上數字"10"的處理 */
                .card[data-text="10"] .card-num {
                    font-size: 1.6rem; /* 數字10使用更小的字體 */
                    transform: scaleX(0.8); /* 壓縮寬度為80% */
                    transform-origin: left top; /* 從左上角開始縮放 */
                    left: 0.5px; /* 稍微調整位置 */
                }
                
                .card-suit-top {
                    font-size: 0.9rem; /* 比1.1rem稍小一點 */
                    top: 1.3px; /* 保持1.3px邊距 */
                    right: 1.3px; /* 保持1.3px邊距 */
                }
                
                .card-center-suit { 
                    font-size: 2.2rem; /* 從2rem增加到2.2rem */
                    bottom: 1.1px; /* 保持離底端1.1px */
                }
                
                /* 特別小的手機上蓋牌上的數字顯示調整 */
                .card-count {
                    font-size: 1.8rem; /* 調整蓋牌數字大小 (從2.0rem調整) */
                }
                
                /* 在特別小的屏幕上調整手機功能區 */
                .mobile-toolbar-container {
                    gap: 8px; /* 減少間距 */
                    padding: 10px 15px; /* 調整padding */
                    min-width: 250px; /* 調整最小寬度 */
                    border-radius: 20px; /* 稍微減小圓角 */
                }
                
                .mobile-toolbar-container button {
                    padding: 10px 12px; /* 調整按鈕大小 */
                    font-size: 11px; /* 調整字體大小 */
                    min-width: 60px; /* 調整最小寬度 */
                }
            }
        }
    </style>
</head>
<body>

<!-- 工具欄區塊 -->
<div class="toolbar">
    <div class="toolbar-left">
        <div class="time-moves-display" id="time-moves">00:00 | 0000步</div>
        <div class="score-display">分數: <span id="current-score">0000</span></div>
    </div>
    <div class="toolbar-buttons">
        <button onclick="showNewGameDialog()" id="new-game-btn">新牌局</button>
        <button onclick="showSettingsDialog()" id="settings-btn">設定</button>
        <button onclick="undoMove()" id="undo-btn" disabled>撤回</button>
        <button onclick="showHint()" id="hint-btn">提示</button>
        <button onclick="magicMove()" id="magic-btn" disabled>魔法</button>
    </div>
</div>

<!-- 訊息提示框 -->
<div id="message"></div>

<!-- 新牌局對話框 -->
<div class="dialog-overlay" id="dialog-overlay" onclick="closeNewGameDialog()"></div>
<div class="new-game-dialog" id="new-game-dialog">
    <h3>新牌局選項</h3>
    <button class="new-game-btn" onclick="startNewGame()">新的遊戲</button>
    <button class="restart-game-btn" onclick="restartCurrentGame()">重玩此局</button>
    <button class="back-btn" onclick="closeNewGameDialog()">返回</button>
</div>

<!-- 設定對話框 -->
<div class="dialog-overlay" id="settings-overlay" onclick="closeSettingsDialog()"></div>
<div class="settings-dialog" id="settings-dialog">
    <h3>遊戲設定</h3>
    
    <div class="settings-option">
        <label>音效開關</label>
        <div class="settings-toggle">
            <button class="settings-option-btn active" id="sound-on" onclick="toggleSound('on')">開</button>
            <button class="settings-option-btn" id="sound-off" onclick="toggleSound('off')">關</button>
        </div>
    </div>
    
    <div class="settings-option">
        <label>手別模式</label>
        <div class="settings-toggle">
            <button class="settings-option-btn active" id="hand-right" onclick="setHandMode('right')">右手</button>
            <button class="settings-option-btn" id="hand-left" onclick="setHandMode('left')">左手</button>
        </div>
    </div>
    
    <div class="settings-option">
        <label>翻牌模式</label>
        <div class="settings-toggle">
            <button class="settings-option-btn active" id="mode-1" onclick="setDrawMode(1)">1張</button>
            <button class="settings-option-btn" id="mode-3" onclick="setDrawMode(3)">3張</button>
        </div>
    </div>
    
    <div class="settings-option">
        <label>剩餘張數顯示</label>
        <div class="settings-toggle">
            <button class="settings-option-btn active" id="count-on" onclick="toggleCardCount('on')">開</button>
            <button class="settings-option-btn" id="count-off" onclick="toggleCardCount('off')">關</button>
        </div>
    </div>
    
    <button class="settings-back-btn" onclick="closeSettingsDialog()">返回</button>
</div>

<!-- 遊戲主區域 -->
<div id="game-board">
    <!-- 手機版功能鍵容器 - 美化版 -->
    <div class="mobile-toolbar-container">
        <button onclick="showNewGameDialog()" id="mobile-new-game-btn">新牌局</button>
        <button onclick="showSettingsDialog()" id="mobile-settings-btn">設定</button>
        <button onclick="undoMove()" id="mobile-undo-btn" disabled>撤回</button>
        <button onclick="showHint()" id="mobile-hint-btn">提示</button>
        <button onclick="magicMove()" id="mobile-magic-btn" disabled>魔法</button>
    </div>

    <!-- 四個花色區槽位 (安置區) - 位置由手別模式決定 -->
    <div id="slot-f0" class="slot" data-type="foundation" data-idx="0"></div>
    <div id="slot-f1" class="slot" data-type="foundation" data-idx="1"></div>
    <div id="slot-f2" class="slot" data-type="foundation" data-idx="2"></div>
    <div id="slot-f3" class="slot" data-type="foundation" data-idx="3"></div>

    <!-- 廢牌堆槽位 - 位置由手別模式決定 -->
    <div id="slot-waste" class="slot"></div>
    
    <!-- 牌堆槽位 (蓋牌區) - 位置由手別模式決定 -->
    <div id="slot-stock" class="slot"></div>

    <!-- 七列表格槽位 -->
    <div id="slot-t0" class="slot" data-type="tableau" data-idx="0"></div>
    <div id="slot-t1" class="slot" data-type="tableau" data-idx="1"></div>
    <div id="slot-t2" class="slot" data-type="tableau" data-idx="2"></div>
    <div id="slot-t3" class="slot" data-type="tableau" data-idx="3"></div>
    <div id="slot-t4" class="slot" data-type="tableau" data-idx="4"></div>
    <div id="slot-t5" class="slot" data-type="tableau" data-idx="5"></div>
    <div id="slot-t6" class="slot" data-type="tableau" data-idx="6"></div>

    <!-- 卡片圖層 -->
    <div id="card-layer"></div>
</div>

<script>
    // ==================== 遊戲常數定義 ====================
    const SUITS = ['♠', '♥', '♣', '♦']; // 花色陣列
    const COLORS = { '♠': 'black', '♥': 'red', '♣': 'black', '♦': 'red' }; // 花色對應顏色
    const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K']; // 牌面值陣列

    // ==================== 遊戲狀態變數 ====================
    let state = {
        stock: [], // 牌堆
        waste: [], // 廢牌堆
        foundations: [[], [], [], []], // 四個花色區
        tableau: [[], [], [], [], [], [], []], // 七列表格
        gameMode: 'guaranteed', // 遊戲模式
        moves: 0, // 移動次數
        startTime: null, // 遊戲開始時間
        timerInterval: null, // 計時器間隔ID
        score: 0, // 初始分數
        drawMode: 1, // 翻牌模式：1張或3張，預設為1張
        handMode: 'right', // 手別模式：右手或左手，預設為右手
        soundEnabled: true, // 音效開關，預設開啟
        showCardCount: true // 是否顯示蓋牌剩餘張數，預設開啟
    };
    
    let history = []; // 遊戲歷史紀錄，用於撤回功能
    let initialGameState = null; // 儲存初始遊戲狀態用於重玩

    // ==================== 拖曳相關變數 ====================
    let drag = {
        isDragging: false, // 是否正在拖曳
        pending: false, // 是否等待拖曳開始
        startX: 0, // 拖曳起始X座標
        startY: 0, // 拖曳起始Y座標
        cards: [], // 拖曳中的卡片陣列
        origin: null, // 拖曳來源資訊
        elGhosts: [], // 拖曳時的幽靈卡片元素陣列
        offset: {x:0, y:0}, // 滑鼠/手指與卡片的偏移量
        gameBoardRect: null // 遊戲區域的邊界資訊
    };
    
    // 雙擊與動畫控制變數
    let lastClickTime = 0; // 上次點擊時間
    let lastClickCardId = null; // 上次點擊的卡片ID
    let isAnimating = false; // 是否正在執行動畫，防止動畫期間重複操作
    
    // ==================== 音效管理系統 ====================
    // 音效上下文
    let audioContext = null;
    
    /**
     * 初始化音效系統
     */
    function initAudio() {
        try {
            if (typeof AudioContext !== 'undefined') {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        } catch (e) {
            console.log("音效初始化失敗，將靜音執行");
        }
    }
    
    /**
     * 播放翻牌音效 - 清脆的喀答聲
     */
    function playFlipSound() {
        if (!audioContext || !state.soundEnabled) return;
        
        try {
            const now = audioContext.currentTime;
            
            // 主音調 - 短促的喀答聲
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800; // 較高頻率，清脆
            oscillator.type = 'sine';
            
            // 極短促的包絡：快速上升，快速衰減
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01); // 快速上升
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05); // 快速衰減
            
            // 開始播放
            oscillator.start(now);
            oscillator.stop(now + 0.1); // 極短的持續時間
        } catch (e) {
            // 音效播放失敗，忽略
        }
    }
    
    /**
     * 播放移動牌音效 - 現代化的輕微滑動聲
     */
    function playMoveSound() {
        if (!audioContext || !state.soundEnabled) return;
        
        try {
            const now = audioContext.currentTime;
            
            // 主音調 - 乾淨的滑動聲
            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            
            // 從中頻率快速滑動到高頻率，模擬滑動聲
            oscillator1.frequency.setValueAtTime(300, now);
            oscillator1.frequency.exponentialRampToValueAtTime(800, now + 0.1);
            oscillator1.type = 'sine';
            
            // 加入一點白色噪音，模擬卡片與桌面的輕微摩擦
            const noiseLength = 0.08;
            const bufferSize = audioContext.sampleRate * noiseLength;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                // 低強度的白色噪音
                output[i] = Math.random() * 0.05 - 0.025;
            }
            
            const noiseSource = audioContext.createBufferSource();
            const noiseGain = audioContext.createGain();
            
            noiseSource.buffer = noiseBuffer;
            noiseSource.connect(noiseGain);
            noiseGain.connect(audioContext.destination);
            
            // 設置音量包絡 - 短促而乾淨
            gainNode1.gain.setValueAtTime(0, now);
            gainNode1.gain.linearRampToValueAtTime(0.1, now + 0.01); // 快速上升
            gainNode1.gain.exponentialRampToValueAtTime(0.001, now + 0.15); // 自然衰減
            
            // 噪音音量包絡
            noiseGain.gain.setValueAtTime(0, now);
            noiseGain.gain.linearRampToValueAtTime(0.02, now + 0.005);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
            
            // 開始播放
            oscillator1.start(now);
            noiseSource.start(now);
            
            // 停止播放
            oscillator1.stop(now + 0.15);
            noiseSource.stop(now + 0.08);
            
        } catch (e) {
            // 音效播放失敗，忽略
        }
    }
    
    /**
     * 播放放置區音效（成功音效）- 清脆的上升音階
     */
    function playFoundationSound() {
        if (!audioContext || !state.soundEnabled) return;
        
        try {
            const now = audioContext.currentTime;
            
            // 三個短促的音階上升
            const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5
            const startTimes = [0, 0.03, 0.06]; // 錯開開始時間
            
            frequencies.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = freq;
                oscillator.type = 'sine';
                
                const startTime = now + startTimes[index];
                
                // 短促的包絡
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.2, startTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.05);
                
                // 開始播放
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.06);
            });
        } catch (e) {
            // 音效播放失敗，忽略
        }
    }
    
    // ==================== 分數計算與更新函數 ====================
    /**
     * 更新分數顯示
     */
    function updateScoreDisplay() {
        const scoreElement = document.getElementById('current-score');
        
        if (state.score >= 0) {
            // 正數或零：格式化為4位數字，前面補零
            const formattedScore = Math.abs(state.score).toString().padStart(4, '0');
            scoreElement.textContent = formattedScore;
        } else {
            // 負數：顯示負號和數字，確保總寬度為4個字符
            const absScore = Math.abs(state.score);
            if (absScore < 10) {
                scoreElement.textContent = `-00${absScore}`;
            } else if (absScore < 100) {
                scoreElement.textContent = `-0${absScore}`;
            } else if (absScore < 1000) {
                scoreElement.textContent = `-${absScore}`;
            } else {
                // 如果負數絕對值大於999，顯示完整數字（會超過4位，但這是極端情況）
                scoreElement.textContent = `-${absScore}`;
            }
        }
    }
    
    /**
     * 增加分數
     * @param {number} points - 要增加的分數
     */
    function addScore(points) {
        state.score += points;
        updateScoreDisplay();
    }
    
    // ==================== 新牌局對話框函數 ====================
    /**
     * 顯示新牌局對話框
     */
    function showNewGameDialog() {
        document.getElementById('dialog-overlay').style.display = 'block';
        document.getElementById('new-game-dialog').style.display = 'block';
    }
    
    /**
     * 關閉新牌局對話框
     */
    function closeNewGameDialog() {
        document.getElementById('dialog-overlay').style.display = 'none';
        document.getElementById('new-game-dialog').style.display = 'none';
    }
    
    /**
     * 開始新遊戲
     */
    function startNewGame() {
        closeNewGameDialog();
        initGame('guaranteed');
    }
    
    /**
     * 重玩當前遊戲
     */
    function restartCurrentGame() {
        closeNewGameDialog();
        
        if (!initialGameState) {
            showMessage("無法重玩此局，請開始新遊戲", 2000);
            return;
        }
        
        // 恢復到初始遊戲狀態
        state.stock = JSON.parse(JSON.stringify(initialGameState.stock));
        state.waste = JSON.parse(JSON.stringify(initialGameState.waste));
        state.foundations = JSON.parse(JSON.stringify(initialGameState.foundations));
        state.tableau = JSON.parse(JSON.stringify(initialGameState.tableau));
        state.moves = 0;
        state.score = 0;
        state.startTime = Date.now();
        
        // 重置歷史
        history = [];
        saveStateToHistory();
        
        // 重新渲染
        render();
        startTimer();
        updateTimer();
        updateScoreDisplay();
        
        showMessage("遊戲已重新開始", 1500);
    }
    
    // ==================== 設定對話框函數 ====================
    /**
     * 顯示設定對話框
     */
    function showSettingsDialog() {
        document.getElementById('settings-overlay').style.display = 'block';
        document.getElementById('settings-dialog').style.display = 'block';
        
        // 更新設定對話框的初始狀態
        updateSettingsDisplay();
    }
    
    /**
     * 關閉設定對話框
     */
    function closeSettingsDialog() {
        document.getElementById('settings-overlay').style.display = 'none';
        document.getElementById('settings-dialog').style.display = 'none';
    }
    
    /**
     * 更新設定對話框顯示
     */
    function updateSettingsDisplay() {
        // 音效開關
        document.getElementById('sound-on').classList.toggle('active', state.soundEnabled);
        document.getElementById('sound-off').classList.toggle('active', !state.soundEnabled);
        
        // 手別模式
        document.getElementById('hand-right').classList.toggle('active', state.handMode === 'right');
        document.getElementById('hand-left').classList.toggle('active', state.handMode === 'left');
        
        // 翻牌模式
        document.getElementById('mode-1').classList.toggle('active', state.drawMode === 1);
        document.getElementById('mode-3').classList.toggle('active', state.drawMode === 3);
        
        // 剩餘張數顯示
        document.getElementById('count-on').classList.toggle('active', state.showCardCount);
        document.getElementById('count-off').classList.toggle('active', !state.showCardCount);
    }
    
    /**
     * 切換音效開關
     * @param {string} setting - 'on' 或 'off'
     */
    function toggleSound(setting) {
        state.soundEnabled = (setting === 'on');
        updateSettingsDisplay();
        
        // 測試音效
        if (state.soundEnabled) {
            playFlipSound();
        }
        
        showMessage(`音效${state.soundEnabled ? '開啟' : '關閉'}`, 1500);
    }
    
    /**
     * 切換剩餘張數顯示
     * @param {string} setting - 'on' 或 'off'
     */
    function toggleCardCount(setting) {
        state.showCardCount = (setting === 'on');
        updateSettingsDisplay();
        render(); // 重新渲染以更新顯示
        
        showMessage(`剩餘張數顯示${state.showCardCount ? '開啟' : '關閉'}`, 1500);
    }
    
    // ==================== 計時器相關函數 ====================
    /**
     * 開始計時器
     */
    function startTimer() {
        if (state.timerInterval) clearInterval(state.timerInterval); // 清除現有計時器
        state.startTime = Date.now(); // 記錄開始時間
        state.timerInterval = setInterval(updateTimer, 1000); // 每秒更新一次
    }
    
    /**
     * 更新計時器顯示
     */
    function updateTimer() {
        if (!state.startTime) return;
        
        // 計算經過的時間
        const elapsed = Date.now() - state.startTime;
        const minutes = Math.floor(elapsed / 60000); // 計算分鐘
        const seconds = Math.floor((elapsed % 60000) / 1000); // 計算秒數
        
        // 格式化步數為4位數字，前面補零
        const formattedMoves = state.moves.toString().padStart(4, '0');
        
        // 更新時間和步數顯示
        const timeMovesElement = document.getElementById('time-moves');
        if (timeMovesElement) {
            timeMovesElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')} | ${formattedMoves}步`;
        }
    }
    
    /**
     * 停止計時器
     */
    function stopTimer() {
        if (state.timerInterval) {
            clearInterval(state.timerInterval);
            state.timerInterval = null;
        }
    }
    
    // ==================== 翻牌模式設定函數 ====================
    /**
     * 設定翻牌模式
     * @param {number} mode - 翻牌模式 (1或3)
     */
    function setDrawMode(mode) {
        if (mode !== 1 && mode !== 3) return;
        
        state.drawMode = mode;
        updateSettingsDisplay();
        
        // 重新渲染以更新廢牌堆顯示
        render();
        
        showMessage(`已切換為一次翻${mode}張牌模式`, 1500);
    }
    
    // ==================== 手別模式設定函數 ====================
    /**
     * 設定手別模式
     * @param {string} mode - 手別模式 ('left' 或 'right')
     */
    function setHandMode(mode) {
        if (mode !== 'left' && mode !== 'right') return;
        
        state.handMode = mode;
        updateSettingsDisplay();
        
        // 重新佈局並渲染
        layoutSlots();
        render();
        
        showMessage(`已切換為${mode === 'right' ? '右手' : '左手'}模式`, 1500);
    }

    // ==================== 遊戲初始化函數 ====================
    /**
     * 初始化遊戲
     * @param {string} mode - 遊戲模式
     */
    function initGame(mode = 'guaranteed') {
        stopTimer(); // 停止計時器
        state.gameMode = mode; // 設定遊戲模式
        state.moves = 0; // 重置移動次數
        state.score = 0; // 重置分數為0
        history = []; // 清空歷史紀錄
        updateUndoButton(); // 更新撤回按鈕狀態
        updateMagicButton(); // 更新魔法按鈕狀態
        
        let deck = []; // 牌組
        if (mode === 'guaranteed') {
            showMessage("新牌局開始！", 2000); // 顯示開始訊息
            deck = createGuaranteedDeck(); // 建立保證可解的牌組
        }

        // 重置遊戲狀態
        state.stock = [];
        state.waste = [];
        state.foundations = [[], [], [], []];
        state.tableau = [[], [], [], [], [], [], []];

        // 發牌到七列表格
        for (let i = 0; i < 7; i++) {
            for (let j = i; j < 7; j++) {
                if (deck.length === 0) break;
                let card = deck.pop(); // 從牌組取牌
                card.id = Math.random().toString(36).substr(2,9); // 產生唯一ID
                card.faceUp = (i === j); // 只有每列最後一張牌面朝上
                state.tableau[j].push(card); // 放入表格
            }
        }

        // 剩餘牌放入牌堆
        state.stock = deck.reverse(); // 反轉牌組順序
        state.stock.forEach(card => {
            card.id = Math.random().toString(36).substr(2,9); // 產生唯一ID
            card.faceUp = false; // 牌堆中的牌面朝下
        });
        
        // 儲存初始遊戲狀態用於重玩
        initialGameState = {
            stock: JSON.parse(JSON.stringify(state.stock)),
            waste: JSON.parse(JSON.stringify(state.waste)),
            foundations: JSON.parse(JSON.stringify(state.foundations)),
            tableau: JSON.parse(JSON.stringify(state.tableau))
        };
        
        saveStateToHistory(); // 儲存初始狀態到歷史紀錄
        layoutSlots(); // 佈局槽位
        render(); // 渲染遊戲畫面
        startTimer(); // 開始計時
        updateTimer(); // 更新時間顯示
        updateScoreDisplay(); // 更新分數顯示
    }
    
    // ==================== 歷史紀錄相關函數 ====================
    /**
     * 儲存當前遊戲狀態到歷史紀錄
     */
    function saveStateToHistory() {
        const stateCopy = {
            stock: JSON.parse(JSON.stringify(state.stock)), // 深拷貝牌堆
            waste: JSON.parse(JSON.stringify(state.waste)), // 深拷貝廢牌堆
            foundations: JSON.parse(JSON.stringify(state.foundations)), // 深拷貝花色區
            tableau: JSON.parse(JSON.stringify(state.tableau)), // 深拷貝表格
            moves: state.moves, // 移動次數
            gameMode: state.gameMode, // 遊戲模式
            startTime: state.startTime, // 開始時間
            score: state.score, // 分數
            drawMode: state.drawMode, // 翻牌模式
            handMode: state.handMode, // 手別模式
            soundEnabled: state.soundEnabled, // 音效開關
            showCardCount: state.showCardCount // 剩餘張數顯示
        };
        history.push(stateCopy); // 加入歷史紀錄
        updateUndoButton(); // 更新撤回按鈕狀態
        updateMagicButton(); // 更新魔法按鈕狀態
    }
    
    /**
     * 撤回上一步移動
     */
    function undoMove() {
        if (isAnimating) return; // 動畫中禁止撤回
        if (history.length <= 1) return; // 沒有歷史紀錄可撤回
        history.pop(); // 移除當前狀態
        const prevState = history[history.length - 1]; // 取得上一個狀態
        
        // 恢復上一個狀態
        state.stock = JSON.parse(JSON.stringify(prevState.stock));
        state.waste = JSON.parse(JSON.stringify(prevState.waste));
        state.foundations = JSON.parse(JSON.stringify(prevState.foundations));
        state.tableau = JSON.parse(JSON.stringify(prevState.tableau));
        state.moves = prevState.moves;
        state.gameMode = prevState.gameMode;
        state.startTime = prevState.startTime;
        state.score = prevState.score;
        state.drawMode = prevState.drawMode;
        state.handMode = prevState.handMode;
        state.soundEnabled = prevState.soundEnabled;
        state.showCardCount = prevState.showCardCount;
        
        // 更新設定顯示
        updateSettingsDisplay();
        
        updateUndoButton(); // 更新撤回按鈕狀態
        updateMagicButton(); // 更新魔法按鈕狀態
        render(); // 重新渲染
        updateTimer(); // 更新時間顯示
        updateScoreDisplay(); // 更新分數顯示
    }
    
    /**
     * 更新撤回按鈕狀態
     */
    function updateUndoButton() {
        const isDisabled = history.length <= 1;
        document.getElementById('undo-btn').disabled = isDisabled;
        document.getElementById('mobile-undo-btn').disabled = isDisabled;
    }
    
    /**
     * 更新魔法按鈕狀態
     */
    function updateMagicButton() {
        // 檢查是否有蓋著的牌
        const hasFacedDownCards = state.tableau.some(pile => 
            pile.some(card => !card.faceUp)
        );
        const isDisabled = !hasFacedDownCards || isAnimating;
        document.getElementById('magic-btn').disabled = isDisabled;
        document.getElementById('mobile-magic-btn').disabled = isDisabled;
    }

    // ==================== 牌組建立函數 ====================
    /**
     * 建立保證可解的牌組
     * @returns {Array} - 牌組陣列
     */
    function createGuaranteedDeck() {
        // 基礎牌組，保證可解
        const baseDeck = [
            {suit: '♠', rank: 5, text: '5', color: 'black'},
            {suit: '♦', rank: 10, text: '10', color: 'red'},
            {suit: '♣', rank: 3, text: '3', color: 'black'},
            {suit: '♥', rank: 8, text: '8', color: 'red'},
            {suit: '♠', rank: 7, text: '7', color: 'black'},
            {suit: '♦', rank: 2, text: '2', color: 'red'},
            {suit: '♣', rank: 9, text: '9', color: 'black'},
            {suit: '♥', rank: 4, text: '4', color: 'red'},
            {suit: '♠', rank: 6, text: '6', color: 'black'},
            {suit: '♦', rank: 1, text: 'A', color: 'red'},
            {suit: '♣', rank: 11, text: 'J', color: 'black'},
            {suit: '♥', rank: 12, text: 'Q', color: 'red'},
            {suit: '♠', rank: 10, text: '10', color: 'black'},
            {suit: '♦', rank: 8, text: '8', color: 'red'},
            {suit: '♣', rank: 5, text: '5', color: 'black'},
            {suit: '♥', rank: 13, text: 'K', color: 'red'},
            {suit: '♠', rank: 3, text: '3', color: 'black'},
            {suit: '♦', rank: 6, text: '6', color: 'red'},
            {suit: '♣', rank: 12, text: 'Q', color: 'black'},
            {suit: '♥', rank: 9, text: '9', color: 'red'},
            {suit: '♠', rank: 1, text: 'A', color: 'black'},
            {suit: '♦', rank: 13, text: 'K', color: 'red'},
            {suit: '♣', rank: 8, text: '8', color: 'black'},
            {suit: '♥', rank: 7, text: '7', color: 'red'},
            {suit: '♠', rank: 12, text: 'Q', color: 'black'},
            {suit: '♦', rank: 4, text: '4', color: 'red'},
            {suit: '♣', rank: 1, text: 'A', color: 'black'},
            {suit: '♥', rank: 1, text: 'A', color: 'red'},
            {suit: '♠', rank: 9, text: '9', color: 'black'},
            {suit: '♦', rank: 3, text: '3', color: 'red'},
            {suit: '♣', rank: 10, text: '10', color: 'black'},
            {suit: '♥', rank: 5, text: '5', color: 'red'},
            {suit: '♠', rank: 2, text: '2', color: 'black'},
            {suit: '♦', rank: 5, text: '5', color: 'red'},
            {suit: '♣', rank: 7, text: '7', color: 'black'},
            {suit: '♥', rank: 11, text: 'J', color: 'red'},
            {suit: '♠', rank: 4, text: '4', color: 'black'},
            {suit: '♦', rank: 7, text: '7', color: 'red'},
            {suit: '♣', rank: 2, text: '2', color: 'black'},
            {suit: '♥', rank: 6, text: '6', color: 'red'},
            {suit: '♠', rank: 11, text: 'J', color: 'black'},
            {suit: '♦', rank: 9, text: '9', color: 'red'},
            {suit: '♣', rank: 4, text: '4', color: 'black'},
            {suit: '♥', rank: 10, text: '10', color: 'red'},
            {suit: '♠', rank: 13, text: 'K', color: 'black'},
            {suit: '♦', rank: 12, text: 'Q', color: 'red'},
            {suit: '♣', rank: 6, text: '6', color: 'black'},
            {suit: '♥', rank: 2, text: '2', color: 'red'},
            {suit: '♠', rank: 8, text: '8', color: 'black'},
            {suit: '♦', rank: 11, text: 'J', color: 'red'},
            {suit: '♣', rank: 13, text: 'K', color: 'black'},
            {suit: '♥', rank: 3, text: '3', color: 'red'}
        ];
        
        const deck = JSON.parse(JSON.stringify(baseDeck)); // 深拷貝基礎牌組
        const rotations = Math.floor(Math.random() * 10); // 隨機旋轉次數
        for (let i = 0; i < rotations; i++) {
            deck.push(deck.shift()); // 旋轉牌組
        }
        return deck;
    }
    
    // ==================== 訊息顯示函數 ====================
    /**
     * 顯示訊息
     * @param {string} text - 訊息內容
     * @param {number} duration - 顯示持續時間(毫秒)
     */
    function showMessage(text, duration = 2000) {
        const messageEl = document.getElementById('message');
        messageEl.textContent = text;
        messageEl.style.display = 'block';
        setTimeout(() => {
            messageEl.style.display = 'none';
        }, duration);
    }
    
    // ==================== 提示系統函數 ====================
    /**
     * 顯示遊戲提示
     */
    function showHint() {
        if (isAnimating) return; // 動畫中不顯示提示
        const hintBtn = document.getElementById('hint-btn');
        const mobileHintBtn = document.getElementById('mobile-hint-btn');
        hintBtn.disabled = true; // 禁用提示按鈕
        mobileHintBtn.disabled = true; // 禁用手機版提示按鈕
        
        // 清除現有高光效果
        document.querySelectorAll('.highlight, .target-highlight').forEach(el => {
            el.classList.remove('highlight', 'target-highlight');
        });
        
        let hint = null;
        
        // 1. 尋找Ace移動
        hint = findAceMove();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { 
                hintBtn.disabled = false; 
                mobileHintBtn.disabled = false;
            }, 500);
            return;
        }
        
        // 2. 尋找花色區移動
        hint = findFoundationMove();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { 
                hintBtn.disabled = false; 
                mobileHintBtn.disabled = false;
            }, 500);
            return;
        }
        
        // 3. 根據翻開牌數量尋找最佳表格移動
        hint = findBestTableauMoveByUncoveredCards();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { 
                hintBtn.disabled = false; 
                mobileHintBtn.disabled = false;
            }, 500);
            return;
        }
        
        // 4. 根據連鎖長度尋找最佳表格移動
        hint = findBestTableauMoveByChainLength();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { 
                hintBtn.disabled = false; 
                mobileHintBtn.disabled = false;
            }, 500);
            return;
        }
        
        // 5. 檢查廢牌區移動
        if (state.waste.length > 0) {
            // 在三張模式下，只能移動廢牌堆最上面的一張牌
            const wasteCard = state.waste[state.waste.length - 1];
            for (let j = 0; j < 4; j++) {
                const foundation = state.foundations[j];
                if (canMoveToFoundation(wasteCard, foundation)) {
                    showMessage(`提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到花色區${j+1}`, 2000);
                    let targetCardId = null;
                    if (foundation.length > 0) {
                        targetCardId = foundation[foundation.length - 1].id;
                    }
                    highlightCardPair(wasteCard.id, 'foundation', j, targetCardId);
                    setTimeout(() => { 
                        hintBtn.disabled = false; 
                mobileHintBtn.disabled = false;
            }, 500);
            return;
        }
    }
    for (let targetCol = 0; targetCol < 7; targetCol++) {
        const targetPile = state.tableau[targetCol];
        if (canMoveToTableau(wasteCard, targetPile)) {
            showMessage(`提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到第${targetCol+1}列`, 2000);
            let targetCardId = null;
            if (targetPile.length > 0) {
                targetCardId = targetPile[targetPile.length - 1].id;
            }
            highlightCardPair(wasteCard.id, 'tableau', targetCol, targetCardId);
            setTimeout(() => { 
                hintBtn.disabled = false; 
                mobileHintBtn.disabled = false;
            }, 500);
            return;
        }
    }
}
        
        // 6. 尋找可翻開的牌
        hint = findFlipCardHint();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCard(hint.cardId);
            setTimeout(() => { 
                hintBtn.disabled = false; 
                mobileHintBtn.disabled = false;
            }, 500);
            return;
        }
        
        // 7. 預設提示
        if (state.stock.length > 0) {
            showMessage(`提示：點擊牌堆來翻開新牌（${state.drawMode}張模式）`, 2000);
            highlightStock();
        } else if (state.waste.length > 0) {
            showMessage("提示：點擊廢牌堆左側的箭頭重新使用廢牌", 2000);
            highlightStock();
        } else {
            showMessage("嘗試移動不同的牌，或者重新開始遊戲", 2000);
        }
        
        setTimeout(() => { 
            hintBtn.disabled = false; 
            mobileHintBtn.disabled = false;
        }, 500);
    }
    
    /**
     * 尋找Ace移動
     * @returns {Object|null} - 提示物件或null
     */
    function findAceMove() {
        // 檢查表格中的Ace
        for (let i = 0; i < 7; i++) {
            const pile = state.tableau[i];
            if (pile.length === 0) continue;
            const topCard = pile[pile.length - 1];
            if (!topCard.faceUp) continue;
            if (topCard.rank === 1) {
                let alreadyInFoundation = false;
                // 檢查是否已在花色區
                for (let j = 0; j < 4; j++) {
                    const foundation = state.foundations[j];
                    if (foundation.length > 0 && foundation[0].suit === topCard.suit) {
                        alreadyInFoundation = true;
                        break;
                    }
                }
                if (!alreadyInFoundation) {
                    return {
                        message: `提示：將第${i+1}列的${topCard.text}${topCard.suit}移到花色區`,
                        sourceCardId: topCard.id,
                        targetType: 'foundation',
                        targetIdx: getEmptyFoundationIndex(),
                        targetCardId: null
                    };
                }
            }
        }
        // 檢查廢牌區中的Ace
        if (state.waste.length > 0) {
            const wasteCard = state.waste[state.waste.length - 1];
            if (wasteCard.rank === 1) {
                let alreadyInFoundation = false;
                for (let j = 0; j < 4; j++) {
                    const foundation = state.foundations[j];
                    if (foundation.length > 0 && foundation[0].suit === wasteCard.suit) {
                        alreadyInFoundation = true;
                        break;
                    }
                }
                if (!alreadyInFoundation) {
                    return {
                        message: `提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到花色區`,
                        sourceCardId: wasteCard.id,
                        targetType: 'foundation',
                        targetIdx: getEmptyFoundationIndex(),
                        targetCardId: null
                    };
                }
            }
        }
        return null;
    }
    
    /**
     * 取得空的花色區索引
     * @returns {number} - 花色區索引
     */
    function getEmptyFoundationIndex() {
        for (let i = 0; i < 4; i++) {
            if (state.foundations[i].length === 0) return i;
        }
        return 0;
    }
    
    /**
     * 尋找花色區移動
     * @returns {Object|null} - 提示物件或null
     */
    function findFoundationMove() {
        // 檢查表格中的牌
        for (let i = 0; i < 7; i++) {
            const pile = state.tableau[i];
            if (pile.length === 0) continue;
            const topCard = pile[pile.length - 1];
            if (!topCard.faceUp) continue;
            for (let j = 0; j < 4; j++) {
                const foundation = state.foundations[j];
                if (canMoveToFoundation(topCard, foundation)) {
                    let targetCardId = null;
                    if (foundation.length > 0) targetCardId = foundation[foundation.length - 1].id;
                    return {
                        message: `提示：將第${i+1}列的${topCard.text}${topCard.suit}移到花色區${j+1}`,
                        sourceCardId: topCard.id,
                        targetType: 'foundation',
                        targetIdx: j,
                        targetCardId: targetCardId
                    };
                }
            }
        }
        // 檢查廢牌區的牌
        if (state.waste.length > 0) {
            const wasteCard = state.waste[state.waste.length - 1];
            for (let j = 0; j < 4; j++) {
                const foundation = state.foundations[j];
                if (canMoveToFoundation(wasteCard, foundation)) {
                    let targetCardId = null;
                    if (foundation.length > 0) targetCardId = foundation[foundation.length - 1].id;
                    return {
                        message: `提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到花色區${j+1}`,
                        sourceCardId: wasteCard.id,
                        targetType: 'foundation',
                        targetIdx: j,
                        targetCardId: targetCardId
                    };
                }
            }
        }
        return null;
    }
    
    /**
     * 根據翻開牌數量尋找最佳表格移動
     * @returns {Object|null} - 提示物件或null
     */
    function findBestTableauMoveByUncoveredCards() {
        let bestMove = null;
        let bestUncoveredCount = -1;
        for (let sourceCol = 0; sourceCol < 7; sourceCol++) {
            const sourcePile = state.tableau[sourceCol];
            if (sourcePile.length === 0) continue;
            let sourceIdx = -1;
            // 尋找最上面翻開的牌
            for (let i = sourcePile.length - 1; i >= 0; i--) {
                if (sourcePile[i].faceUp) {
                    sourceIdx = i;
                    break;
                }
            }
            if (sourceIdx === -1) continue;
            const card = sourcePile[sourceIdx];
            // 檢查所有目標列
            for (let targetCol = 0; targetCol < 7; targetCol++) {
                if (sourceCol === targetCol) continue;
                const targetPile = state.tableau[targetCol];
                if (canMoveToTableau(card, targetPile)) {
                    // 計算移動後會翻開多少張牌
                    let uncoveredCount = 0;
                    if (sourceIdx > 0 && !sourcePile[sourceIdx - 1].faceUp) uncoveredCount = 1;
                    // 選擇翻開最多牌的移動
                    if (uncoveredCount > bestUncoveredCount) {
                        bestUncoveredCount = uncoveredCount;
                        let targetCardId = null;
                        if (targetPile.length > 0) targetCardId = targetPile[targetPile.length - 1].id;
                        bestMove = {
                            sourceCol, targetCol, card,
                            message: `提示：將第${sourceCol+1}列的${card.text}${card.suit}移到第${targetCol+1}列`,
                            sourceCardId: card.id,
                            targetType: 'tableau',
                            targetIdx: targetCol,
                            targetCardId: targetCardId
                        };
                    }
                }
            }
        }
        return bestMove;
    }
    
    /**
     * 根據連鎖長度尋找最佳表格移動
     * @returns {Object|null} - 提示物件或null
     */
    function findBestTableauMoveByChainLength() {
        let bestMove = null;
        let bestChainLength = -1;
        for (let sourceCol = 0; sourceCol < 7; sourceCol++) {
            const sourcePile = state.tableau[sourceCol];
            if (sourcePile.length === 0) continue;
            let sourceIdx = -1;
            // 尋找最上面翻開的牌
            for (let i = sourcePile.length - 1; i >= 0; i--) {
                if (sourcePile[i].faceUp) {
                    sourceIdx = i;
                    break;
                }
            }
            if (sourceIdx === -1) continue;
            const card = sourcePile[sourceIdx];
            const chainLength = sourcePile.length - sourceIdx; // 計算連鎖長度
            // 檢查所有目標列
            for (let targetCol = 0; targetCol < 7; targetCol++) {
                if (sourceCol === targetCol) continue;
                const targetPile = state.tableau[targetCol];
                if (canMoveToTableau(card, targetPile)) {
                    // 選擇最長連鎖的移動
                    if (chainLength > bestChainLength) {
                        bestChainLength = chainLength;
                        let targetCardId = null;
                        if (targetPile.length > 0) targetCardId = targetPile[targetPile.length - 1].id;
                        bestMove = {
                            sourceCol, targetCol, card,
                            message: `提示：將第${sourceCol+1}列的${card.text}${card.suit}移到第${targetCol+1}列`,
                            sourceCardId: card.id,
                            targetType: 'tableau',
                            targetIdx: targetCol,
                            targetCardId: targetCardId
                        };
                    }
                }
            }
        }
        return bestMove;
    }
    
    /**
     * 尋找可翻開的牌
     * @returns {Object|null} - 提示物件或null
     */
    function findFlipCardHint() {
        for (let i = 0; i < 7; i++) {
            const pile = state.tableau[i];
            if (pile.length > 0) {
                const topCard = pile[pile.length - 1];
                if (!topCard.faceUp) {
                    return {
                        message: `提示：點擊第${i+1}列最上面的蓋牌來翻牌`,
                        cardId: topCard.id
                    };
                }
            }
        }
        return null;
    }
    
    /**
     * 高光顯示單張卡片
     * @param {string} cardId - 卡片ID
     */
    function highlightCard(cardId) {
        if (!cardId) return;
        const cardElement = document.querySelector(`[data-id="${cardId}"]`);
        if (cardElement) {
            cardElement.classList.add('highlight');
            setTimeout(() => { cardElement.classList.remove('highlight'); }, 2000);
        }
    }
    
    /**
     * 高光顯示卡片對（來源和目標）
     * @param {string} sourceCardId - 來源卡片ID
     * @param {string} targetType - 目標類型
     * @param {number} targetIdx - 目標索引
     * @param {string} targetCardId - 目標卡片ID
     */
    function highlightCardPair(sourceCardId, targetType, targetIdx, targetCardId = null) {
        // 高光源卡片
        const sourceElement = document.querySelector(`[data-id="${sourceCardId}"]`);
        if (sourceElement) {
            sourceElement.classList.add('highlight');
            setTimeout(() => { sourceElement.classList.remove('highlight'); }, 2000);
        }
        // 高光目標
        if (targetCardId) {
            const targetElement = document.querySelector(`[data-id="${targetCardId}"]`);
            if (targetElement) {
                targetElement.classList.add('target-highlight');
                setTimeout(() => { targetElement.classList.remove('target-highlight'); }, 2000);
            }
        } else if (targetType === 'foundation') {
            const foundationSlot = document.querySelector(`#slot-f${targetIdx}`);
            if (foundationSlot) {
                foundationSlot.classList.add('target-highlight');
                setTimeout(() => { foundationSlot.classList.remove('target-highlight'); }, 2000);
            }
        } else if (targetType === 'tableau') {
            const tableauSlot = document.querySelector(`#slot-t${targetIdx}`);
            if (tableauSlot) {
                tableauSlot.classList.add('target-highlight');
                setTimeout(() => { tableauSlot.classList.remove('target-highlight'); }, 2000);
            }
        }
    }
    
    /**
     * 高光顯示牌堆
     */
    function highlightStock() {
        const stockElement = document.querySelector('#slot-stock');
        if (stockElement) {
            stockElement.classList.add('highlight');
            setTimeout(() => { stockElement.classList.remove('highlight'); }, 2000);
        }
    }
    
    // ==================== 移動規則檢查函數 ====================
    /**
     * 檢查是否可以移動到花色區
     * @param {Object} card - 卡片物件
     * @param {Array} foundation - 花色區陣列
     * @returns {boolean} - 是否可以移動
     */
    function canMoveToFoundation(card, foundation) {
        if (foundation.length === 0) return card.rank === 1; // 空的花色區只能放Ace
        const topCard = foundation[foundation.length - 1]; // 花色區最上面的牌
        return card.suit === topCard.suit && card.rank === topCard.rank + 1; // 同花色且數字連續
    }
    
    /**
     * 檢查是否可以移動到表格
     * @param {Object} card - 卡片物件
     * @param {Array} tableauPile - 表格列陣列
     * @returns {boolean} - 是否可以移動
     */
    function canMoveToTableau(card, tableauPile) {
        if (tableauPile.length === 0) return card.rank === 13; // 空的表格列只能放King
        const topCard = tableauPile[tableauPile.length - 1]; // 表格列最上面的牌
        return card.color !== topCard.color && card.rank === topCard.rank - 1; // 不同顏色且數字連續
    }

    // ==================== 佈局計算函數 ====================
    let slotPositions = {}; // 槽位位置資訊
    let cardSize = {width: 0, height: 0}; // 卡片尺寸
    
    /**
     * 佈局所有槽位
     */
    function layoutSlots() {
        const board = document.getElementById('game-board');
        const w = board.clientWidth; // 遊戲區域寬度
        
        // 建立測量元素計算卡片尺寸
        const measure = document.createElement('div');
        measure.className = 'slot';
        board.appendChild(measure);
        cardSize.width = measure.offsetWidth;
        cardSize.height = measure.offsetHeight;
        board.removeChild(measure);

        // 檢查是否為手機版
        const isMobile = window.innerWidth < 600;
        if (isMobile) {
            // 限制手機上最大卡片尺寸
            const maxCardWidth = Math.min(cardSize.width, 75); // 從70增加到75
            const maxCardHeight = Math.min(cardSize.height, 105); // 從98增加到105
            cardSize.width = maxCardWidth;
            cardSize.height = maxCardHeight;
        }

        // 計算間距
        const gap = Math.max(0.5, (w - (cardSize.width * 7)) / 8); // 最小間距0.5px
        
        /**
         * 設定槽位位置
         * @param {string} id - 槽位ID
         * @param {number} x - X座標
         * @param {number} y - Y座標
         */
        const setPos = (id, x, y) => {
            const el = document.getElementById(id);
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            // 儲存位置資訊
            slotPositions[id] = { 
                left: x, top: y, right: x + cardSize.width, bottom: y + cardSize.height,
                cx: x + cardSize.width/2, cy: y + cardSize.height/2
            };
        };

        // 上方區域佈局
        const topRowY = 10;
        
        // 計算三張牌需要的總寬度：卡片寬度 + 2 * (卡片寬度 * 0.3)
        const wasteTotalWidth = cardSize.width * (1 + 0.3 * 2);
        
        if (state.handMode === 'right') {
            // 右手模式：花色區在左，廢牌堆在中間（靠右），牌堆在最右邊
            // 1. 四個花色區（安置區）放在最左邊
            for(let i=0; i<4; i++) {
                setPos(`slot-f${i}`, gap + i * (cardSize.width + gap), topRowY);
            }
            
            // 2. 廢牌堆放在牌堆左邊，但要為三張牌留出空間，向左移動
            const wasteX = w - gap - cardSize.width - wasteTotalWidth - gap;
            setPos('slot-waste', wasteX, topRowY);
            
            // 3. 牌堆（蓋牌區）放在最右邊
            const stockX = w - gap - cardSize.width;
            setPos('slot-stock', stockX, topRowY);
        } else {
            // 左手模式：牌堆在左，廢牌堆在牌堆右邊，花色區在右邊
            // 關鍵修正：牌堆和廢牌堆的距離應該與右手模式對稱
            // 在右手模式中，牌堆在右，廢牌堆在牌堆左邊一個gap的位置（但考慮三張牌寬度）
            // 在左手模式中，牌堆在左，廢牌堆應該在牌堆右邊一個gap的位置（但考慮三張牌寬度）
            
            // 1. 牌堆（蓋牌區）放在最左邊
            const stockX = gap;
            setPos('slot-stock', stockX, topRowY);
            
            // 2. 廢牌堆放在牌堆右邊，距離為一個gap（與右手模式對稱）
            // 注意：這裡不需要為三張牌留出空間，因為牌是向右展開的
            // 但在計算位置時，我們需要考慮三張牌模式下的視覺對齊
            const wasteX = stockX + cardSize.width + gap;
            setPos('slot-waste', wasteX, topRowY);
            
            // 3. 四個花色區（安置區）放在最右邊
            // 計算花色區需要的總寬度：4張卡片 + 3個間距
            const foundationsTotalWidth = 4 * cardSize.width + 3 * gap;
            // 花色區右邊緣對齊屏幕右邊緣減去一個gap
            const foundationsRight = w - gap;
            // 花色區左邊緣位置
            const foundationsLeft = foundationsRight - foundationsTotalWidth;
            
            // 設置花色區位置，從左到右排列
            for(let i=0; i<4; i++) {
                const foundationX = foundationsLeft + i * (cardSize.width + gap);
                setPos(`slot-f${i}`, foundationX, topRowY);
            }
        }
        
        // 下方七列表格佈局
        const tableauY = topRowY + cardSize.height + (isMobile ? 10 : 30); // 手機上減少間距
        for(let i=0; i<7; i++) {
            let x = gap * (i+1) + cardSize.width * i;
            setPos(`slot-t${i}`, x, tableauY);
        }
    }

    // ==================== 渲染引擎函數 ====================
    /**
     * 渲染遊戲畫面
     */
    function render() {
        const layer = document.getElementById('card-layer');
        layer.innerHTML = ''; // 清空圖層

        /**
         * 繪製單張卡片
         * @param {Object} card - 卡片物件
         * @param {number} x - X座標
         * @param {number} y - Y座標
         * @param {string} type - 卡片類型
         * @param {number} pileIdx - 所在堆疊索引
         * @param {number} cardIdx - 卡片在堆疊中的索引
         * @param {boolean} isWaste - 是否為廢牌堆卡片
         * @param {number} wasteOffset - 廢牌堆偏移量
         */
        const drawCard = (card, x, y, type, pileIdx, cardIdx, isWaste = false, wasteOffset = 0) => {
            const div = document.createElement('div');
            div.className = `card ${card.faceUp ? '' : 'back'}`;
            
            // 計算卡片位置
            let finalX = x;
            if (isWaste && wasteOffset > 0) {
                finalX += wasteOffset;
            }
            
            div.style.left = finalX + 'px';
            div.style.top = y + 'px';
            div.dataset.id = card.id;
            div.dataset.type = type;
            div.dataset.pileIdx = pileIdx;
            div.dataset.cardIdx = cardIdx;
            div.dataset.text = card.text; // 添加牌面文字用於CSS選擇器

            if (card.faceUp) {
                div.classList.add(card.color);
                div.innerHTML = `
                    <div class="card-face">
                        <div class="card-num ${card.color}">${card.text}</div>
                        <div class="card-suit-top ${card.color}">${card.suit}</div>
                        <div class="card-center-suit ${card.color}">${card.suit}</div>
                    </div>
                `;
                
                // 添加拖曳事件監聽器
                // 在三張模式下，廢牌堆只有最上面的牌可以拖曳
                if (type !== 'waste' || cardIdx === state.waste.length - 1) {
                    div.addEventListener('mousedown', (e) => startDrag(e, type, pileIdx, cardIdx));
                    div.addEventListener('touchstart', (e) => startDrag(e, type, pileIdx, cardIdx), {passive: false});
                }
                
            } else {
                // 背面朝上的卡片添加點擊事件
                if (type === 'stock') {
                    div.addEventListener('click', () => drawStockWithAnimation());
                } else if (type === 'tableau') {
                    const pile = state.tableau[pileIdx];
                    if (cardIdx === pile.length - 1) {
                        div.addEventListener('click', () => flipTableauCard(pileIdx));
                    }
                }
            }
            layer.appendChild(div);
        };

        // 繪製牌堆
        const sPos = slotPositions['slot-stock'];
        if (state.stock.length > 0) {
            // 創建牌堆卡片
            const stockDiv = document.createElement('div');
            stockDiv.className = 'card back';
            stockDiv.style.left = sPos.left + 'px';
            stockDiv.style.top = sPos.top + 'px';
            stockDiv.dataset.type = 'stock';
            
            // 添加牌堆剩餘數量顯示（根據設定）
            if (state.showCardCount) {
                const countDiv = document.createElement('div');
                countDiv.className = 'card-count';
                countDiv.textContent = state.stock.length;
                stockDiv.appendChild(countDiv);
            }
            
            stockDiv.addEventListener('click', () => drawStockWithAnimation());
            layer.appendChild(stockDiv);
        } else {
            // 牌堆為空時顯示重新整理按鈕
            const emptyStock = document.createElement('div');
            emptyStock.style.cssText = `position:absolute; left:${sPos.left}px; top:${sPos.top}px; width:${cardSize.width}px; height:${cardSize.height}px;`;
            emptyStock.innerHTML = '<div class="refresh-btn">↺</div>';
            emptyStock.addEventListener('click', resetStock);
            layer.appendChild(emptyStock);
        }

        // 繪製廢牌堆
        const wPos = slotPositions['slot-waste'];
        const wasteLen = state.waste.length;
        
        if (wasteLen > 0) {
            if (state.drawMode === 3 && wasteLen >= 3) {
                // 三張模式：顯示最近的三張牌
                const displayCards = state.waste.slice(-3); // 取最後三張牌
                
                // 計算每張牌的偏移量 - 確保最舊的在左邊（偏移0），最新的在右邊（偏移最大）
                for (let i = 0; i < 3; i++) {
                    const card = displayCards[i];
                    // 第一張（最舊）偏移0，第二張偏移30%，第三張（最新）偏移60%
                    const offset = i * (cardSize.width * 0.3);
                    drawCard(card, wPos.left, wPos.top, 'waste', 0, wasteLen-3+i, true, offset);
                }
            } else if (state.drawMode === 3 && wasteLen < 3) {
                // 三張模式但牌不夠三張
                for (let i = 0; i < wasteLen; i++) {
                    const card = state.waste[i];
                    // 計算偏移：每張牌向右偏移卡片寬度的30%
                    const offset = i * (cardSize.width * 0.3);
                    drawCard(card, wPos.left, wPos.top, 'waste', 0, i, true, offset);
                }
            } else {
                // 一張模式：只顯示最上面的一張牌
                const topWasteCard = state.waste[wasteLen - 1];
                drawCard(topWasteCard, wPos.left, wPos.top, 'waste', 0, wasteLen - 1);
            }
        }

        // 繪製四個花色區
        for(let i=0; i<4; i++) {
            const pos = slotPositions[`slot-f${i}`];
            const pile = state.foundations[i];
            if (pile.length > 0) {
                drawCard(pile[pile.length-1], pos.left, pos.top, 'foundation', i, pile.length-1);
            }
        }

        // 繪製七列表格
        for(let i=0; i<7; i++) {
            const pos = slotPositions[`slot-t${i}`];
            const pile = state.tableau[i];
            let currentOffset = 0; // 當前偏移量
            pile.forEach((card, idx) => {
                if (idx > 0) {
                    const prevCard = pile[idx - 1];
                    
                    // 分開手機版和網頁版的重疊比例計算邏輯
                    let overlapRatio;
                    const isMobile = window.innerWidth < 600;
                    
                    if (isMobile) {
                        // 手機版重疊比例計算邏輯
                        if (prevCard.faceUp) {
                            overlapRatio = card.faceUp ? 0.5 : 0.9;
                        } else {
                            overlapRatio = 0.9;
                        }
                    } else {
                        // 網頁版重疊比例計算邏輯（保持原樣不變）
                        if (prevCard.faceUp) {
                            overlapRatio = card.faceUp ? 0.7 : 0.9;
                        } else {
                            overlapRatio = 0.9;
                        }
                    }
                    
                    currentOffset += cardSize.height * (1 - overlapRatio); // 計算偏移量
                }
                drawCard(card, pos.left, pos.top + currentOffset, 'tableau', i, idx);
            });
        }
        
        // 更新魔法按鈕狀態
        updateMagicButton();
    }
    
    /**
     * 翻開表格中的卡片
     * @param {number} pileIdx - 表格列索引
     */
    function flipTableauCard(pileIdx) {
        if (isAnimating) return;
        const pile = state.tableau[pileIdx];
        if (pile.length > 0) {
            const topCard = pile[pile.length - 1];
            if (!topCard.faceUp) {
                // 播放翻牌音效
                playFlipSound();
                
                topCard.faceUp = true; // 翻開卡片
                state.moves++; // 增加移動次數
                addScore(5); // 翻開一張牌得5分
                saveStateToHistory(); // 儲存狀態
                render(); // 重新渲染
                updateTimer(); // 更新計時器
            }
        }
    }

    // ==================== 翻牌動畫邏輯 ====================
    /**
     * 從牌堆抽牌（帶動畫）- 修正：當從牌堆翻最後一張牌時，先清除蓋牌再動畫
     */
    function drawStockWithAnimation() {
        if (isAnimating) return;
        if (state.stock.length === 0) return;
        
        isAnimating = true; // 標記動畫開始
        
        const drawCount = Math.min(state.drawMode, state.stock.length); // 實際要翻開的牌數
        
        // 取得牌堆和廢牌堆的視窗座標
        const stockSlot = document.getElementById('slot-stock');
        const wasteSlot = document.getElementById('slot-waste');
        
        if (!stockSlot || !wasteSlot) return;
        
        const stockRect = stockSlot.getBoundingClientRect();
        const wasteRect = wasteSlot.getBoundingClientRect();
        
        // 先從牌堆中取出牌，保持正確的順序
        const cardsToDraw = [];
        for (let i = 0; i < drawCount; i++) {
            // 從牌堆頂部取牌（最後一張是最上面的牌）
            const cardIndex = state.stock.length - 1 - i;
            cardsToDraw.unshift(state.stock[cardIndex]); // 使用 unshift 確保順序正確
        }
        
        // 現在 cardsToDraw 的順序是：[最舊的牌, ..., 最新的牌]
        // 索引0是最舊的牌，索引 drawCount-1 是最新的牌
        
        // 如果這是最後一張牌，先移除牌堆的視覺元素
        if (state.stock.length === drawCount) {
            // 移除牌堆的視覺元素
            const stockCardElement = document.querySelector('.card[data-type="stock"]');
            if (stockCardElement) {
                stockCardElement.style.opacity = '0';
                stockCardElement.style.transition = 'opacity 0.1s';
                
                // 等待透明度過渡完成
                setTimeout(() => {
                    if (stockCardElement.parentNode) {
                        stockCardElement.parentNode.removeChild(stockCardElement);
                    }
                }, 100);
            }
        }
        
        // 為每張牌創建動畫卡片
        const animationCards = [];
        
        // 創建動畫卡片，從最舊的牌開始動畫（這樣視覺上舊牌先飛出，新牌後飛出）
        for (let i = 0; i < drawCount; i++) {
            const card = cardsToDraw[i];
            const animCard = document.createElement('div');
            animCard.className = `card draw-animation-card back`;
            animCard.style.left = stockRect.left + 'px';
            animCard.style.top = stockRect.top + 'px';
            animCard.style.width = stockRect.width + 'px';
            animCard.style.height = stockRect.height + 'px';
            
            // 添加data-text屬性，以便CSS樣式正確應用
            animCard.dataset.text = card.text;
            
            // 確保背景為白色
            animCard.style.backgroundColor = 'white';
            
            document.body.appendChild(animCard);
            animationCards.push({card, element: animCard, index: originalIndex});
        }
        
        // 保持順序，最舊的牌先動畫，最新的牌最後動畫
        animationCards.forEach((item, animIndex) => {
            const {card, element: animCard, index: originalIndex} = item;
            
            // 強制瀏覽器 Reflow 以確保動畫發生
            void animCard.offsetWidth;
            
            // 計算目標位置
            // 在廢牌堆中，最舊的牌在左邊（偏移0），最新的牌在右邊（偏移最大）
            // originalIndex 是 cardsToDraw 中的索引，0=最舊，drawCount-1=最新
            // 所以偏移量是：originalIndex * (cardSize.width * 0.3)
            let targetLeft = wasteRect.left + (originalIndex * (cardSize.width * 0.3));
            let targetTop = wasteRect.top;
            
            // 設置動畫
            animCard.style.left = targetLeft + 'px';
            animCard.style.top = targetTop + 'px';
            
            // 每張牌延遲50毫秒翻面，最舊的牌先翻面
            setTimeout(() => {
                animCard.classList.remove('back');
                animCard.classList.add(card.color);
                
                // 針對數字10的特殊處理 - 只在手機版應用
                let numHtml = `<div class="card-num ${card.color}">${card.text}</div>`;
                const isMobile = window.innerWidth < 600;
                if (card.text === "10" && isMobile) {
                    // 如果是10且是手機版，添加特殊的CSS類
                    numHtml = `<div class="card-num ${card.color}" style="font-size: 2.5rem; transform: scaleX(0.75); transform-origin: left top; left: 0.8px;">${card.text}</div>`;
                } else if (card.text === "10") {
                    // 如果是10且是桌面版，使用正常樣式
                    numHtml = `<div class="card-num ${card.color}" style="font-size: 1.8rem;">${card.text}</div>`;
                }
                
                animCard.innerHTML = `
                    <div class="card-face">
                        ${numHtml}
                        <div class="card-suit-top ${card.color}">${card.suit}</div>
                        <div class="card-center-suit ${card.color}">${card.suit}</div>
                    </div>
                `;
                
                // 播放翻牌音效
                playFlipSound();
            }, animIndex * 50);
        });
        
        // 動畫完成後更新遊戲狀態
        setTimeout(() => {
            // 移除動畫卡片
            animationCards.forEach(item => item.element.remove());
            
            // 更新遊戲狀態 - 先從牌堆取出牌
            const drawnCards = [];
            for (let i = 0; i < drawCount; i++) {
                drawnCards.unshift(state.stock.pop()); // unshift 保持順序：[最舊, ..., 最新]
            }
            // 將取出的牌加入廢牌堆
            drawnCards.forEach(card => {
                card.faceUp = true;
                state.waste.push(card); // push 確保最新的牌在最後（最上面）
            });
            
            state.moves++; // 增加移動次數
            addScore(5 * drawCount); // 每張牌得5分
            saveStateToHistory(); // 儲存狀態
            render(); // 重新渲染
            updateTimer(); // 更新計時器
            
            isAnimating = false; // 標記動畫結束
        }, 400 + (drawCount * 50));
    }

    /**
     * 重置牌堆（將廢牌堆放回牌堆）
     */
    function resetStock() {
        if (isAnimating) return;
        if (state.waste.length === 0) return;
        
        // 在三張模式下，需要保持廢牌堆的順序
        // 經典接龍規則：當牌堆用完時，將廢牌堆的牌翻轉後重新成為牌堆，順序不變
        state.stock = state.waste.reverse().map(c => { 
            c.faceUp = false; // 將牌面朝下
            return c; 
        });
        state.waste = []; // 清空廢牌堆
        state.moves++; // 增加移動次數
        addScore(-100); // 重新循環廢牌堆扣100分
        saveStateToHistory(); // 儲存狀態
        render(); // 重新渲染
        updateTimer(); // 更新計時器
    }

    // ==================== 自動移動動畫函數 ====================
    /**
     * 執行卡片移動動畫
     * @param {Array} cards - 要移動的卡片陣列
     * @param {Object} sourceRect - 來源位置矩形
     * @param {Object} targetRect - 目標位置矩形
     * @param {Function} onComplete - 動畫完成後的回呼函數
     * @param {string} moveType - 移動類型 ('tableau', 'foundation', 'waste')
     */
    function animateMove(cards, sourceRect, targetRect, onComplete, moveType = 'tableau') {
        isAnimating = true; // 標記動畫開始
        const ghosts = []; // 幽靈卡片陣列
        
        // 分開手機版和網頁版的重疊比例
        const isMobile = window.innerWidth < 600;
        const overlapRatio = isMobile ? 0.5 : 0.7; // 手機版50%，網頁版70%
        
        // 建立幽靈卡片
        cards.forEach((card, i) => {
            const ghost = document.createElement('div');
            ghost.className = `card flying-card ${card.color}`;
            ghost.style.backgroundColor = 'white'; // 確保背景為白色
            
            // 添加data-text屬性
            ghost.dataset.text = card.text;
            
            // 針對數字10的特殊處理 - 只在手機版應用
            let numHtml = `<div class="card-num ${card.color}">${card.text}</div>`;
            if (card.text === "10" && isMobile) {
                // 如果是10且是手機版，添加特殊的CSS樣式
                numHtml = `<div class="card-num ${card.color}" style="font-size: 2.5rem; transform: scaleX(0.75); transform-origin: left top; left: 0.8px;">${card.text}</div>`;
            } else if (card.text === "10") {
                // 如果是10且是桌面版，使用正常樣式
                numHtml = `<div class="card-num ${card.color}" style="font-size: 1.8rem;">${card.text}</div>`;
            }
            
            ghost.innerHTML = `
                <div class="card-face">
                    ${numHtml}
                    <div class="card-suit-top ${card.color}">${card.suit}</div>
                    <div class="card-center-suit ${card.color}">${card.suit}</div>
                </div>
            `;
            
            // 計算堆疊偏移量
            const overlapHeight = cardSize.height * overlapRatio;
            const offset = i * (cardSize.height - overlapHeight);

            // 設定初始位置
            ghost.style.left = sourceRect.left + 'px';
            ghost.style.top = (sourceRect.top + offset) + 'px';
            ghost.style.width = cardSize.width + 'px';
            ghost.style.height = cardSize.height + 'px';
            
            document.body.appendChild(ghost);
            ghosts.push(ghost);
        });

        // 強制瀏覽器 Reflow 以確保動畫發生
        void ghosts[0].offsetWidth;

        // 設定目標位置
        ghosts.forEach((ghost, i) => {
            const overlapHeight = cardSize.height * overlapRatio;
            const offset = i * (cardSize.height - overlapHeight);
            
            ghost.style.left = targetRect.left + 'px';
            ghost.style.top = (targetRect.top + offset) + 'px';
        });

        // 根據移動類型播放對應音效
        if (moveType === 'foundation') {
            playFoundationSound();
        } else {
            playMoveSound();
        }

        // 動畫結束後清理
        setTimeout(() => {
            ghosts.forEach(g => g.remove()); // 移除幽靈卡片
            isAnimating = false; // 標記動畫結束
            if (onComplete) onComplete(); // 執行回呼函數
        }, 300); // 配合 CSS transition 0.3s
    }

    // ==================== 魔法按鈕功能 ====================
    /**
     * 魔法移動：隨機翻開一張蓋牌並移動到廢牌堆
     */
    function magicMove() {
        if (isAnimating) return;
        
        // 收集所有蓋著的牌（只收集每列最上面一張蓋牌）
        const facedDownCards = [];
        for (let col = 0; col < 7; col++) {
            const pile = state.tableau[col];
            // 找到每列最上面一張蓋牌
            for (let i = pile.length - 1; i >= 0; i--) {
                if (!pile[i].faceUp) {
                    // 確保這是該列最上面的蓋牌（上面沒有其他蓋牌）
                    if (i === pile.length - 1 || pile[i+1].faceUp) {
                        facedDownCards.push({
                            card: pile[i],
                            pileIdx: col,
                            cardIdx: i,
                            pile: pile
                        });
                        break; // 只取最上面一張蓋牌
                    }
                }
            }
        }
        
        // 如果沒有蓋著的牌，禁用按鈕並返回
        if (facedDownCards.length === 0) {
            updateMagicButton();
            showMessage("沒有可翻開的蓋牌", 1500);
            return;
        }
        
        // 隨機選擇一張蓋牌
        const randomIndex = Math.floor(Math.random() * facedDownCards.length);
        const selected = facedDownCards[randomIndex];
        const { card, pileIdx, cardIdx, pile } = selected;
        
        isAnimating = true; // 標記動畫開始
        updateMagicButton(); // 更新魔法按鈕狀態
        
        // 取得廢牌堆位置
        const wasteSlot = document.getElementById('slot-waste');
        if (!wasteSlot) return;
        
        const wasteRect = wasteSlot.getBoundingClientRect();
        
        // 獲取選中卡片的位置
        const cardElement = document.querySelector(`[data-id="${card.id}"]`);
        if (!cardElement) {
            // 如果卡片元素不存在（可能尚未渲染），則直接更新狀態
            performMagicMove(card, pileIdx, cardIdx, pile);
            return;
        }
        
        const sourceRect = cardElement.getBoundingClientRect();
        
        // 創建魔法動畫卡片（帶加強版金光閃閃效果）
        const magicCard = document.createElement('div');
        magicCard.className = `card magic-animation-card back golden-glow`;
        magicCard.style.left = sourceRect.left + 'px';
        magicCard.style.top = sourceRect.top + 'px';
        magicCard.style.width = sourceRect.width + 'px';
        magicCard.style.height = sourceRect.height + 'px';
        
        // 添加data-text屬性
        magicCard.dataset.text = card.text;
        
        // 確保背景為白色
        magicCard.style.backgroundColor = 'white';
        
        document.body.appendChild(magicCard);
        
        // 強制瀏覽器 Reflow 以確保動畫發生
        void magicCard.offsetWidth;
        
        // 計算目標位置（廢牌堆最右邊的位置）
        let targetLeft, targetTop;
        if (state.drawMode === 3 && state.waste.length >= 3) {
            // 三張模式，已有三張牌，新牌放在最右邊
            targetLeft = wasteRect.left + (2 * (cardSize.width * 0.3));
        } else if (state.drawMode === 3 && state.waste.length < 3) {
            // 三張模式，牌不夠三張，新牌放在適當位置
            targetLeft = wasteRect.left + (state.waste.length * (cardSize.width * 0.3));
        } else {
            // 一張模式，新牌放在廢牌堆位置
            targetLeft = wasteRect.left;
        }
        targetTop = wasteRect.top;
        
        // 設置動畫
        magicCard.style.left = targetLeft + 'px';
        magicCard.style.top = targetTop + 'px';
        
        // 動畫中途翻開卡片
        setTimeout(() => {
            magicCard.classList.remove('back');
            magicCard.classList.add(card.color);
            
            // 針對數字10的特殊處理 - 只在手機版應用
            const isMobile = window.innerWidth < 600;
            let numHtml = `<div class="card-num ${card.color}">${card.text}</div>`;
            if (card.text === "10" && isMobile) {
                // 如果是10且是手機版，添加特殊的CSS樣式
                numHtml = `<div class="card-num ${card.color}" style="font-size: 2.5rem; transform: scaleX(0.75); transform-origin: left top; left: 0.8px;">${card.text}</div>`;
            } else if (card.text === "10") {
                // 如果是10且是桌面版，使用正常樣式
                numHtml = `<div class="card-num ${card.color}" style="font-size: 1.8rem;">${card.text}</div>`;
            }
            
            magicCard.innerHTML = `
                <div class="card-face">
                    ${numHtml}
                    <div class="card-suit-top ${card.color}">${card.suit}</div>
                    <div class="card-center-suit ${card.color}">${card.suit}</div>
                </div>
            `;
            
            // 播放翻牌音效
            playFlipSound();
        }, 250);
        
        // 動畫完成後更新遊戲狀態
        setTimeout(() => {
            // 移除動畫卡片
            magicCard.remove();
            
            // 執行魔法移動
            performMagicMove(card, pileIdx, cardIdx, pile);
        }, 500);
    }
    
    /**
     * 執行魔法移動（更新遊戲狀態）
     */
    function performMagicMove(card, pileIdx, cardIdx, pile) {
        // 從表格中移除卡片
        pile.splice(cardIdx, 1);
        
        // 翻開卡片
        card.faceUp = true;
        
        // 添加到廢牌堆（最上面）
        state.waste.push(card);
        
        // 更新遊戲狀態
        state.moves++; // 增加移動次數
        addScore(-20); // 使用魔法扣20分
        
        // 如果表格列還有牌，確保最上面一張是翻開的
        if (state.tableau[pileIdx].length > 0) {
            const newTopCard = state.tableau[pileIdx][state.tableau[pileIdx].length - 1];
            if (!newTopCard.faceUp) {
                newTopCard.faceUp = true;
            }
        }
        
        saveStateToHistory(); // 儲存狀態
        render(); // 重新渲染
        updateTimer(); // 更新計時器
        
        isAnimating = false; // 標記動畫結束
        updateMagicButton(); // 更新魔法按鈕狀態
        
        showMessage(`魔法發動！翻開了${card.text}${card.suit}`, 1500);
    }

    // ==================== 雙擊自動移動邏輯 ====================
    /**
     * 處理雙擊事件
     * @param {string} type - 卡片類型
     * @param {number} pileIdx - 堆疊索引
     * @param {number} cardIdx - 卡片索引
     * @param {string} cardId - 卡片ID
     */
    function handleDoubleClick(type, pileIdx, cardIdx, cardId) {
        if (type === 'foundation') return; // 花色區的牌不能雙擊移動
        if (isAnimating) return; // 動畫中禁止操作
        
        let sourcePile;
        let card;
        let cardsToMove = [];
        
        // 根據卡片類型取得來源堆疊和卡片
        if (type === 'tableau') {
            sourcePile = state.tableau[pileIdx];
            if (cardIdx < 0 || cardIdx >= sourcePile.length) return;
            card = sourcePile[cardIdx];
            
            if (!card.faceUp) return; // 背面朝上的牌不能移動
            
            // 檢查卡片上方是否有未翻開的牌
            for (let i = cardIdx + 1; i < sourcePile.length; i++) {
                if (!sourcePile[i].faceUp) {
                    shakeCard(cardId); // 震動提示
                    return;
                }
            }
            
            // 取得要移動的所有牌（從點擊的牌到最後一張）
            cardsToMove = sourcePile.slice(cardIdx);
        } else if (type === 'waste') {
            sourcePile = state.waste;
            if (cardIdx !== sourcePile.length - 1) return; // 只能移動最上面的牌
            card = sourcePile[cardIdx];
            cardsToMove = [card];
        } else {
            return;
        }

        // 取得來源位置 (用於動畫)
        const cardEl = document.querySelector(`[data-id="${cardId}"]`);
        if (!cardEl) return;
        const sourceRect = cardEl.getBoundingClientRect();
        
        // 1. 嘗試移動到花色區
        for (let i = 0; i < 4; i++) {
            const foundation = state.foundations[i];
            if (canMoveToFoundation(card, foundation)) {
                // 花色區只能移動最上面的單張牌
                if (cardsToMove.length > 1) {
                    shakeCard(cardId); // 不能移動多張牌到花色區
                    return;
                }
                
                // 從原始位置移除牌
                if (type === 'tableau') {
                    state.tableau[pileIdx].splice(cardIdx, 1);
                    // 如果還有牌，翻開最上面一張
                    if (state.tableau[pileIdx].length > 0) {
                        state.tableau[pileIdx][state.tableau[pileIdx].length - 1].faceUp = true;
                    }
                } else if (type === 'waste') {
                    state.waste.pop();
                }
                
                // 立即重新渲染以移除原始位置的牌
                render();
                
                // 取得目標位置
                const targetEl = document.getElementById(`slot-f${i}`);
                const targetRect = targetEl.getBoundingClientRect();
                
                // 播放動畫
                animateMove(cardsToMove, sourceRect, targetRect, () => {
                    // 動畫結束後將牌添加到目標位置
                    state.foundations[i].push(...cardsToMove);
                    
                    state.moves++;
                    // 根據移動類型加分
                    if (type === 'waste') {
                        addScore(10); // 從廢牌堆移動到花色區得10分
                    } else {
                        addScore(10); // 從表格列移動到花色區得10分
                    }
                    saveStateToHistory();
                    render(); // 重新渲染以顯示目標位置的牌
                    updateTimer();
                    checkWin(); // 檢查是否獲勝
                }, 'foundation');
                return; 
            }
        }
        
        // 2. 嘗試移動到表格
        for (let targetIdx = 0; targetIdx < 7; targetIdx++) {
            if (type === 'tableau' && targetIdx === pileIdx) continue;
            const targetPile = state.tableau[targetIdx];
            
            if (card.rank === 13 && targetPile.length === 0 && type === 'tableau' && cardIdx === 0) continue; 

            if (canMoveToTableau(card, targetPile)) {
                // 從原始位置移除牌
                if (type === 'tableau') {
                    state.tableau[pileIdx].splice(cardIdx, cardsToMove.length);
                    // 如果還有牌，翻開最上面一張
                    if (state.tableau[pileIdx].length > 0) {
                        state.tableau[pileIdx][state.tableau[pileIdx].length - 1].faceUp = true;
                    }
                } else if (type === 'waste') {
                    state.waste.pop();
                }
                
                // 立即重新渲染以移除原始位置的牌
                render();
                
                // 取得目標位置
                let targetRect;
                if (targetPile.length > 0) {
                    const topCardId = targetPile[targetPile.length-1].id;
                    const topCardEl = document.querySelector(`[data-id="${topCardId}"]`);
                    const rect = topCardEl.getBoundingClientRect();
                    targetRect = { 
                        left: rect.left, 
                        top: rect.top + (cardSize.height * 0.3) // 估算偏移量
                    };
                } else {
                    const slotEl = document.getElementById(`slot-t${targetIdx}`);
                    targetRect = slotEl.getBoundingClientRect();
                }

                // 播放動畫
                animateMove(cardsToMove, sourceRect, targetRect, () => {
                    // 動畫結束後將牌添加到目標位置
                    state.tableau[targetIdx].push(...cardsToMove);
                    
                    state.moves++;
                    // 根據移動類型加分
                    if (type === 'waste') {
                        addScore(5); // 從廢牌堆移動到表格列得5分
                    } else {
                        addScore(5 * cardsToMove.length); // 從表格列移動到表格列，每張牌得5分
                    }
                    saveStateToHistory();
                    render(); // 重新渲染以顯示目標位置的牌
                    updateTimer();
                    checkWin(); // 檢查是否獲勝
                }, 'tableau');
                return;
            }
        }
        
        // 3. 失敗則震動
        shakeCard(cardId);
    }
    
    /**
     * 震動卡片效果
     * @param {string} cardId - 卡片ID
     */
    function shakeCard(cardId) {
        const cardElement = document.querySelector(`[data-id="${cardId}"]`);
        if (cardElement) {
            cardElement.classList.remove('shake');
            void cardElement.offsetWidth; // 強制重繪
            cardElement.classList.add('shake');
            setTimeout(() => { cardElement.classList.remove('shake'); }, 400);
        }
    }

    // ==================== 拖曳系統函數 ====================
    /**
     * 開始拖曳
     * @param {Event} e - 事件物件
     * @param {string} type - 卡片類型
     * @param {number} pileIdx - 堆疊索引
     * @param {number} cardIdx - 卡片索引
     */
    function startDrag(e, type, pileIdx, cardIdx) {
        if (isAnimating) return; // 動畫中禁止拖曳
        e.stopPropagation(); // 停止事件冒泡
        
        const now = Date.now(); // 當前時間
        
        // 根據類型取得來源堆疊和卡片
        let sourcePile = (type === 'tableau') ? state.tableau[pileIdx] : (type === 'waste' ? state.waste : []);
        if (type === 'foundation') sourcePile = state.foundations[pileIdx];
        const clickedCard = sourcePile[cardIdx];
        if (!clickedCard) return;

        // 雙擊檢測
        if (clickedCard.id === lastClickCardId && now - lastClickTime < 350) {
            handleDoubleClick(type, pileIdx, cardIdx, clickedCard.id);
            lastClickCardId = null;
            lastClickTime = 0;
            return;
        }
        
        lastClickCardId = clickedCard.id;
        lastClickTime = now;

        if (drag.isDragging || drag.pending) return; // 已在拖曳中

        if (!clickedCard.faceUp) return; // 背面朝上的牌不能拖曳
        
        // 在三張模式下，廢牌堆只能拖曳最上面的牌
        if (type === 'waste' && cardIdx !== sourcePile.length - 1) return;
        
        if ((type === 'waste' || type === 'foundation') && cardIdx !== sourcePile.length - 1) return; // 只能拖曳最上面的牌
        
        drag.pending = true; // 標記為等待拖曳
        drag.isDragging = false;
        
        // 取得觸控/滑鼠座標
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        
        drag.startX = clientX;
        drag.startY = clientY;
        drag.origin = { type, pileIdx, cardIdx };
        
        // 設定要拖曳的卡片
        drag.cards = [];
        if (type === 'tableau') {
            // 表格中拖曳從點擊位置到最下面的所有牌
            for (let i = cardIdx; i < sourcePile.length; i++) {
                drag.cards.push(sourcePile[i]);
            }
        } else {
            // 廢牌堆和花色區只能拖曳一張牌
            drag.cards.push(clickedCard);
        }

        // 取得遊戲區域邊界
        const gameBoard = document.getElementById('game-board');
        drag.gameBoardRect = gameBoard.getBoundingClientRect();
        
        // 計算偏移量
        const cardEl = document.querySelector(`[data-id="${clickedCard.id}"]`);
        if (cardEl) {
            const rect = cardEl.getBoundingClientRect();
            drag.offset.x = clientX - rect.left;
            drag.offset.y = clientY - rect.top;
        }

        // 添加事件監聽器
        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    }

    /**
     * 建立拖曳時的幽靈卡片
     */
    function createGhosts() {
        if (!drag.cards.length) return;
        
        const startCardEl = document.querySelector(`[data-id="${drag.cards[0].id}"]`);
        if (!startCardEl) return;
        const rect = startCardEl.getBoundingClientRect();

        // 為每張拖曳中的卡片建立幽靈卡片
        drag.cards.forEach((card, i) => {
            const ghost = document.createElement('div');
            ghost.className = `card dragging-card ${card.color}`;
            ghost.style.backgroundColor = 'white'; // 確保背景為白色
            
            // 添加data-text屬性
            ghost.dataset.text = card.text;
            
            // 針對數字10的特殊處理 - 只在手機版應用
            const isMobile = window.innerWidth < 600;
            let numHtml = `<div class="card-num ${card.color}">${card.text}</div>`;
            if (card.text === "10" && isMobile) {
                // 如果是10且是手機版，添加特殊的CSS樣式
                numHtml = `<div class="card-num ${card.color}" style="font-size: 2.5rem; transform: scaleX(0.75); transform-origin: left top; left: 0.8px;">${card.text}</div>`;
            } else if (card.text === "10") {
                // 如果是10且是桌面版，使用正常樣式
                numHtml = `<div class="card-num ${card.color}" style="font-size: 1.8rem;">${card.text}</div>`;
            }
            
            ghost.innerHTML = `
                <div class="card-face">
                    ${numHtml}
                    <div class="card-suit-top ${card.color}">${card.suit}</div>
                    <div class="card-center-suit ${card.color}">${card.suit}</div>
                </div>
            `;
            
            // 分開手機版和網頁版的重疊比例
            const overlapRatio = isMobile ? 0.5 : 0.7; // 手機版50%，網頁版70%
            const overlapHeight = cardSize.height * overlapRatio;
            const ghostOffset = i * (cardSize.height - overlapHeight);
            
            // 設定初始位置
            ghost.style.left = rect.left + 'px';
            ghost.style.top = (rect.top + ghostOffset) + 'px';
            ghost.style.width = rect.width + 'px';
            ghost.style.height = rect.height + 'px';
            
            document.body.appendChild(ghost);
            drag.elGhosts.push(ghost);
        });

        // 將原始卡片設為半透明
        drag.cards.forEach(card => {
            const el = document.querySelector(`[data-id="${card.id}"]`);
            if (el) el.style.opacity = '0.3';
        });
    }

    /**
     * 拖曳移動處理函數
     * @param {Event} e - 事件物件
     */
    function onDragMove(e) {
        if (!drag.pending && !drag.isDragging) return;
        
        // 取得觸控/滑鼠座標
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        
        // 檢查是否真正開始拖曳（移動距離超過5px）
        if (drag.pending) {
            const moveX = Math.abs(clientX - drag.startX);
            const moveY = Math.abs(clientY - drag.startY);
            
            if (moveX > 5 || moveY > 5) {
                drag.pending = false;
                drag.isDragging = true;
                createGhosts(); // 建立幽靈卡片
            } else {
                return;
            }
        }
        
        // 更新幽靈卡片位置
        if (drag.isDragging) {
            if (e.cancelable) e.preventDefault(); // 防止預設行為
            
            drag.elGhosts.forEach((el, i) => {
                // 分開手機版和網頁版的重疊比例
                const isMobile = window.innerWidth < 600;
                const overlapRatio = isMobile ? 0.5 : 0.7; // 手機版50%，網頁版70%
                const overlapHeight = cardSize.height * overlapRatio;
                const ghostOffset = i * (cardSize.height - overlapHeight);
                
                el.style.left = (clientX - drag.offset.x) + 'px';
                el.style.top = (clientY - drag.offset.y + ghostOffset) + 'px';
            });
        }
    }

    /**
     * 拖曳結束處理函數
     * @param {Event} e - 事件物件
     */
    function onDragEnd(e) {
        // 移除事件監聽器
        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);

        // 處理等待拖曳狀態
        if (drag.pending) {
            drag.pending = false;
            return;
        }

        if (!drag.isDragging) return; // 未在拖曳中

        // 取得幽靈卡片位置
        const headGhost = drag.elGhosts[0];
        const ghostRect = headGhost.getBoundingClientRect();
        
        // 計算相對遊戲區域的位置
        const ghostLeftRelative = ghostRect.left - drag.gameBoardRect.left;
        const ghostTopRelative = ghostRect.top - drag.gameBoardRect.top;
        const ghostCenterX = ghostLeftRelative + ghostRect.width / 2;
        const ghostCenterY = ghostTopRelative + ghostRect.height / 2;

        let target = null; // 目標位置
        
        // 檢查是否拖曳到花色區
        for (let i = 0; i < 4; i++) {
            const s = slotPositions[`slot-f${i}`];
            if (!s) continue;
            if (ghostCenterX >= s.left && ghostCenterX <= s.right && 
                ghostCenterY >= s.top && ghostCenterY <= s.bottom + 50) {
                target = { type: 'foundation', idx: i };
                break;
            }
        }
        
        // 檢查是否拖曳到表格
        if (!target) {
            for (let i = 0; i < 7; i++) {
                const s = slotPositions[`slot-t${i}`];
                if (!s) continue;
                if (ghostCenterX >= s.left - 30 && ghostCenterX <= s.right + 30 && 
                    ghostCenterY >= s.top - 50) {
                    target = { type: 'tableau', idx: i };
                    break;
                }
            }
        }

        // 嘗試移動卡片
        let success = false;
        if (target) {
            success = tryMove(drag.cards, drag.origin, target);
        }

        // 清理幽靈卡片
        drag.elGhosts.forEach(el => el.remove());
        drag.elGhosts = [];
        drag.isDragging = false;
        
        // 恢復原始卡片透明度
        drag.cards.forEach(card => {
            const el = document.querySelector(`[data-id="${card.id}"]`);
            if (el) el.style.opacity = '1';
        });

        // 根據移動結果更新遊戲
        if (success) {
            state.moves++;
            saveStateToHistory();
            render();
            updateTimer();
            checkWin(); // 檢查是否獲勝
        } else {
            render(); // 移動失敗，重新渲染恢復原狀
        }
    }

    /**
     * 嘗試移動卡片
     * @param {Array} cards - 要移動的卡片陣列
     * @param {Object} source - 來源資訊
     * @param {Object} target - 目標資訊
     * @returns {boolean} - 移動是否成功
     */
    function tryMove(cards, source, target) {
        if (!cards || cards.length === 0) return false;
        const moveCard = cards[0]; // 移動的第一張卡片
        
        // 移動到花色區
        if (target.type === 'foundation') {
            if (cards.length > 1) return false; // 花色區只能移動一張牌
            const foundation = state.foundations[target.idx];
            if (foundation.length === 0) {
                if (moveCard.rank !== 1) return false; // 空的花色區只能放Ace
            } else {
                const topCard = foundation[foundation.length - 1];
                if (moveCard.suit !== topCard.suit || moveCard.rank !== topCard.rank + 1) return false; // 必須同花色且連續
            }
            performMove(source, target, cards); // 執行移動
            return true;
        }
        
        // 移動到表格
        if (target.type === 'tableau') {
            if (source.type === 'tableau' && source.pileIdx === target.idx) return false; // 不能移動到同一列
            const tableau = state.tableau[target.idx];
            if (tableau.length === 0) {
                if (moveCard.rank !== 13) return false; // 空的表格列只能放King
            } else {
                const topCard = tableau[tableau.length - 1];
                if (moveCard.color === topCard.color || moveCard.rank !== topCard.rank - 1) return false; // 必須不同顏色且連續
            }
            performMove(source, target, cards); // 執行移動
            return true;
        }
        return false;
    }

    /**
     * 執行移動操作
     * @param {Object} source - 來源資訊
     * @param {Object} target - 目標資訊
     * @param {Array} cards - 要移動的卡片陣列
     */
    function performMove(source, target, cards) {
        // 從來源移除卡片
        if (source.type === 'waste') {
            state.waste.splice(source.cardIdx, 1);
        } else if (source.type === 'tableau') {
            state.tableau[source.pileIdx].splice(source.cardIdx, cards.length);
            if (state.tableau[source.pileIdx].length > 0) {
                state.tableau[source.pileIdx][state.tableau[source.pileIdx].length - 1].faceUp = true; // 翻開下一張牌
            }
        } else if (source.type === 'foundation') {
            state.foundations[source.pileIdx].splice(source.cardIdx, 1);
        }
        
        // 添加到目標
        if (target.type === 'foundation') {
            state.foundations[target.idx].push(...cards);
            // 根據來源加分
            if (source.type === 'waste') {
                addScore(10); // 從廢牌堆移動到花色區得10分
            } else if (source.type === 'tableau') {
                addScore(10); // 從表格列移動到花色區得10分
            }
            // 播放放置區音效
            playFoundationSound();
        } else if (target.type === 'tableau') {
            state.tableau[target.idx].push(...cards);
            // 根據來源加分
            if (source.type === 'waste') {
                addScore(5); // 從廢牌堆移動到表格列得5分
            } else if (source.type === 'tableau') {
                addScore(5 * cards.length); // 從表格列移動到表格列，每張牌得5分
            }
            // 播放移動音效
            playMoveSound();
        }
    }

    // ==================== 遊戲結束檢查 ====================
    /**
     * 檢查是否獲勝
     */
    function checkWin() {
        let totalCards = 0;
        state.foundations.forEach(pile => totalCards += pile.length); // 計算花色區總牌數
        if (totalCards === 52) { // 所有牌都在花色區
            stopTimer(); // 停止計時器
            setTimeout(() => {
                alert(`🎉 恭喜破關！ 🎉\n移動次數：${state.moves}\n最終分數：${state.score}`);
            }, 200);
        }
    }

    // ==================== 頁面載入和事件監聽 ====================
    window.addEventListener('load', () => {
        // 初始化音效系統
        initAudio();
        
        // 初始化遊戲
        initGame('guaranteed'); // 初始化遊戲
        window.addEventListener('resize', layoutSlots); // 監聽視窗大小變化
    });
    
    // 防止手機雙指縮放
    document.addEventListener('gesturestart', function (e) {
        e.preventDefault();
    });
</script>
</body>
</html>