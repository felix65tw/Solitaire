<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>經典接龍 (手機適配版)</title>
    <style>
        :root {
            --bg-color: #35654d;
            --card-width: 13vw;
            --card-height: 18.2vw;
            --max-w: 100px;
            --max-h: 140px;
            --gap: 2vw;
        }

        body {
            background-color: var(--bg-color);
            margin: 0;
            overflow: hidden; 
            user-select: none;
            font-family: sans-serif;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* 改善觸控響應 */
        }

        .toolbar {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px; /* 手機上減少padding */
            color: white;
            background: rgba(0,0,0,0.2);
        }
        
        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toolbar-title {
            font-size: 14px; /* 手機上字體小一點 */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .score-display {
            font-size: 14px;
            font-weight: bold;
            color: #FFD700;
            padding: 2px 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            min-width: 60px;
            text-align: center;
        }
        
        .toolbar-buttons {
            display: flex;
            gap: 5px; /* 手機上按鈕間距小一點 */
        }
        
        button {
            background: white;
            border: none;
            padding: 6px 10px; /* 手機上按鈕小一點 */
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px; /* 手機上字體小一點 */
            white-space: nowrap;
        }
        
        button:hover {
            background: #f0f0f0;
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        #message {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10000;
            display: none;
            font-size: 14px;
            max-width: 90%;
            text-align: center;
        }

        #game-board {
            position: relative;
            width: 100vw;
            height: calc(100vh - 50px);
            max-width: 800px;
            margin: 0 auto;
            margin-top: 5px; /* 手機上減少上邊距 */
            overflow: hidden; /* 防止溢出 */
        }

        .slot {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            max-width: var(--max-w);
            max-height: var(--max-h);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-sizing: border-box;
        }

        .card {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            max-width: var(--max-w);
            max-height: var(--max-h);
            background-color: white;
            border-radius: 6px;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            cursor: pointer;
            box-sizing: border-box;
            /* 讓卡片切換位置時平滑一點，但手動拖曳時我們會覆蓋這個設定 */
            transition: box-shadow 0.2s;
            -webkit-user-drag: none; /* 防止拖曳圖片 */
        }

        /* 用於自動移動時的飛行卡片 */
        .flying-card {
            position: fixed;
            z-index: 99999;
            pointer-events: none;
            transition: all 0.3s ease-in-out; /* 這裡控制飛行速度 */
        }

        .card-face {
            width: 100%;
            height: 100%;
            position: relative;
            pointer-events: none;
        }

        /* 左上角數字 */
        .card-num { 
            font-size: 1.8rem; 
            font-weight: 800; 
            line-height: 1;
            position: absolute;
            top: 8px;
            left: 8px;
        }
        
        /* 右上角花色 */
        .card-suit-top { 
            font-size: 1.8rem; 
            line-height: 1; 
            position: absolute;
            top: 8px;
            right: 8px;
        }
        
        /* 卡片中間的大花色 */
        .card-center-suit {
            position: absolute;
            top: 62%; /* 原本是 50%，改成 62% 往下移 */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: normal;
        }
        
        .red { color: #d32f2f; }
        .black { color: #212121; }

        .back {
            background: repeating-linear-gradient(
                45deg,
                #1565c0,
                #1565c0 10px,
                #0d47a1 10px,
                #0d47a1 20px
            );
            border: 2px solid #fff;
        }

        .dragging-card {
            position: fixed; 
            z-index: 9999;
            pointer-events: none; 
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            opacity: 0.9;
        }

        .refresh-btn {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; color: rgba(255,255,255,0.5);
            cursor: pointer;
        }

        /* [修改] 高光效果：增加 pointer-events: none 防止擋住點擊 */
        .highlight {
            animation: yellowPulse 0.8s infinite alternate;
            box-shadow: 0 0 0 4px #FFEB3B, 0 0 20px 8px #FFEB3B !important;
            border: 2px solid #FFEB3B !important;
            z-index: 1000;
            pointer-events: none; /* 關鍵修復：讓點擊穿透高光框 */
        }

        .target-highlight {
            animation: targetPulse 0.8s infinite alternate;
            box-shadow: 0 0 0 4px #4CAF50, 0 0 20px 8px #4CAF50 !important;
            border: 2px solid #4CAF50 !important;
            z-index: 999;
            pointer-events: none; /* 關鍵修復 */
        }

        @keyframes yellowPulse {
            0% { box-shadow: 0 0 0 4px #FFEB3B, 0 0 20px 8px #FFEB3B !important; transform: scale(1.02); }
            100% { box-shadow: 0 0 0 6px #FFEB3B, 0 0 30px 12px #FFEB3B !important; transform: scale(1.05); }
        }

        @keyframes targetPulse {
            0% { box-shadow: 0 0 0 4px #4CAF50, 0 0 20px 8px #4CAF50 !important; transform: scale(1.02); }
            100% { box-shadow: 0 0 0 6px #4CAF50, 0 0 30px 12px #4CAF50 !important; transform: scale(1.05); }
        }

        /* 抖動動畫 */
        .shake {
            animation: shake 0.4s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            16% { transform: translateX(-6px); }
            33% { transform: translateX(6px); }
            50% { transform: translateX(-6px); }
            66% { transform: translateX(6px); }
            83% { transform: translateX(-6px); }
        }

        /* 桌面版樣式 - 維持原始文字和花色大小 */
        @media (min-width: 600px) {
            :root {
                --card-width: 80px;
                --card-height: 112px;
                --gap: 15px;
            }
            /* 桌面版保持原始大小 */
            .card-num, .card-suit-top { font-size: 1.8rem; }
            .card-center-suit { font-size: 4rem; }
            
            .toolbar {
                padding: 0 20px;
            }
            
            .toolbar-title {
                font-size: 16px;
            }
            
            .toolbar-buttons {
                gap: 10px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 14px;
            }
            
            .score-display {
                font-size: 16px;
                padding: 4px 12px;
            }
        }

        /* 手機版專用樣式 */
        @media (max-width: 599px) {
            :root {
                --card-width: 11vw; /* 手機上卡片更小 */
                --card-height: 15.4vw; /* 保持16:9比例 */
                --gap: 1.5vw;
            }
            
            /* 手機上卡片字體調整 */
            .card-num, .card-suit-top { 
                font-size: 1.2rem; 
                top: 5px;
                left: 5px;
            }
            
            .card-suit-top {
                right: 5px;
            }
            
            /* 手機上中間花色調整為更小 */
            .card-center-suit { 
                font-size: 2rem; /* 從2.5rem改為2rem */
                top: 58%; /* 稍微向上調整以適應更小的字體 */
            }
            
            /* 手機上工具欄調整 */
            .toolbar {
                height: 45px;
                padding: 0 8px;
            }
            
            .toolbar-title {
                font-size: 12px;
                max-width: 30%;
            }
            
            .toolbar-buttons {
                gap: 4px;
            }
            
            button {
                padding: 5px 8px;
                font-size: 11px;
                border-radius: 3px;
            }
            
            .score-display {
                font-size: 12px;
                padding: 2px 6px;
                min-width: 50px;
            }
            
            #game-board {
                height: calc(100vh - 45px);
                margin-top: 3px;
            }
            
            /* 手機上訊息框調整 */
            #message {
                font-size: 12px;
                padding: 8px 15px;
                top: 50px;
                max-width: 95%;
            }
            
            /* 特別小的手機 */
            @media (max-width: 320px) {
                :root {
                    --card-width: 10.5vw;
                    --card-height: 14.7vw;
                }
                
                .toolbar-title {
                    font-size: 11px;
                }
                
                button {
                    padding: 4px 6px;
                    font-size: 10px;
                }
                
                .score-display {
                    font-size: 11px;
                }
                
                .card-center-suit { 
                    font-size: 1.8rem; /* 在更小的屏幕上再小一點 */
                }
            }
        }

        /* 橫屏模式 */
        @media (max-height: 500px) and (orientation: landscape) {
            :root {
                --card-width: 9vw;
                --card-height: 12.6vw;
                --gap: 1vw;
            }
            
            #game-board {
                margin-top: 2px;
            }
            
            .toolbar {
                height: 40px;
            }
            
            .toolbar-title {
                font-size: 11px;
            }
            
            .score-display {
                font-size: 11px;
            }
            
            #game-board {
                height: calc(100vh - 40px);
            }
        }
    </style>
</head>
<body>

<div class="toolbar">
    <div class="toolbar-left">
        <span class="toolbar-title">經典接龍</span>
        <div class="score-display">分數: <span id="current-score">1000</span></div>
    </div>
    <div class="toolbar-buttons">
        <button onclick="initGame('guaranteed')" id="new-game-btn">新牌局</button>
        <button onclick="undoMove()" id="undo-btn" disabled>撤回</button>
        <button onclick="showHint()" id="hint-btn">提示</button>
    </div>
</div>

<div id="message"></div>

<div id="game-board">
    <div id="slot-stock" class="slot"></div>
    <div id="slot-waste" class="slot"></div>
    <div id="slot-f0" class="slot" data-type="foundation" data-idx="0"></div>
    <div id="slot-f1" class="slot" data-type="foundation" data-idx="1"></div>
    <div id="slot-f2" class="slot" data-type="foundation" data-idx="2"></div>
    <div id="slot-f3" class="slot" data-type="foundation" data-idx="3"></div>

    <div id="slot-t0" class="slot" data-type="tableau" data-idx="0"></div>
    <div id="slot-t1" class="slot" data-type="tableau" data-idx="1"></div>
    <div id="slot-t2" class="slot" data-type="tableau" data-idx="2"></div>
    <div id="slot-t3" class="slot" data-type="tableau" data-idx="3"></div>
    <div id="slot-t4" class="slot" data-type="tableau" data-idx="4"></div>
    <div id="slot-t5" class="slot" data-type="tableau" data-idx="5"></div>
    <div id="slot-t6" class="slot" data-type="tableau" data-idx="6"></div>

    <div id="card-layer"></div>
</div>

<script>
    // --- 遊戲常數 ---
    const SUITS = ['♠', '♥', '♣', '♦'];
    const COLORS = { '♠': 'black', '♥': 'red', '♣': 'black', '♦': 'red' };
    const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

    // --- 遊戲狀態 ---
    let state = {
        stock: [],
        waste: [],
        foundations: [[], [], [], []],
        tableau: [[], [], [], [], [], [], []],
        gameMode: 'guaranteed',
        moves: 0,
        startTime: null,
        timerInterval: null,
        score: 1000
    };
    
    let history = [];

    // --- 拖曳暫存 & 雙擊檢測變數 ---
    let drag = {
        isDragging: false,
        pending: false,
        startX: 0,
        startY: 0,
        cards: [],
        origin: null,
        elGhosts: [],
        offset: {x:0, y:0},
        gameBoardRect: null
    };
    
    // 雙擊與動畫控制
    let lastClickTime = 0;
    let lastClickCardId = null;
    let isAnimating = false; // 防止動畫期間重複操作
    
    // --- 分數計算與更新 ---
    function updateScore() {
        // 計算當前分數
        const elapsed = state.startTime ? Date.now() - state.startTime : 0;
        const timeBonus = Math.max(0, 600 - Math.floor(elapsed / 10000)) * 10;
        const movesBonus = Math.max(0, 100 - state.moves) * 5;
        state.score = 1000 + timeBonus + movesBonus;
        
        // 更新顯示
        document.getElementById('current-score').textContent = state.score;
    }
    
    // --- 計時器 ---
    function startTimer() {
        if (state.timerInterval) clearInterval(state.timerInterval);
        state.startTime = Date.now();
        updateScore(); // 初始化分數
        state.timerInterval = setInterval(updateTimer, 1000);
    }
    
    function updateTimer() {
        if (!state.startTime) return;
        
        // 更新時間顯示
        const elapsed = Date.now() - state.startTime;
        const minutes = Math.floor(elapsed / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        
        const timerElement = document.querySelector('.toolbar-title');
        if (timerElement) {
            timerElement.textContent = `接龍 | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')} | ${state.moves}步`;
        }
        
        // 更新分數
        updateScore();
    }
    
    function stopTimer() {
        if (state.timerInterval) {
            clearInterval(state.timerInterval);
            state.timerInterval = null;
        }
    }

    // --- 初始化 ---
    function initGame(mode = 'guaranteed') {
        stopTimer();
        state.gameMode = mode;
        state.moves = 0;
        state.score = 1000;
        history = [];
        updateUndoButton();
        
        let deck = [];
        if (mode === 'guaranteed') {
            showMessage("新牌局開始！", 2000);
            deck = createGuaranteedDeck();
        }

        state.stock = [];
        state.waste = [];
        state.foundations = [[], [], [], []];
        state.tableau = [[], [], [], [], [], [], []];

        for (let i = 0; i < 7; i++) {
            for (let j = i; j < 7; j++) {
                if (deck.length === 0) break;
                let card = deck.pop();
                card.id = Math.random().toString(36).substr(2,9);
                card.faceUp = (i === j);
                state.tableau[j].push(card);
            }
        }

        state.stock = deck.reverse();
        state.stock.forEach(card => {
            card.id = Math.random().toString(36).substr(2,9);
            card.faceUp = false;
        });
        
        saveStateToHistory();
        layoutSlots();
        render();
        startTimer();
    }
    
    function saveStateToHistory() {
        const stateCopy = {
            stock: JSON.parse(JSON.stringify(state.stock)),
            waste: JSON.parse(JSON.stringify(state.waste)),
            foundations: JSON.parse(JSON.stringify(state.foundations)),
            tableau: JSON.parse(JSON.stringify(state.tableau)),
            moves: state.moves,
            gameMode: state.gameMode,
            startTime: state.startTime,
            score: state.score
        };
        history.push(stateCopy);
        updateUndoButton();
    }
    
    function undoMove() {
        if (isAnimating) return; // 動畫中禁止撤回
        if (history.length <= 1) return;
        history.pop();
        const prevState = history[history.length - 1];
        
        state.stock = JSON.parse(JSON.stringify(prevState.stock));
        state.waste = JSON.parse(JSON.stringify(prevState.waste));
        state.foundations = JSON.parse(JSON.stringify(prevState.foundations));
        state.tableau = JSON.parse(JSON.stringify(prevState.tableau));
        state.moves = prevState.moves;
        state.gameMode = prevState.gameMode;
        state.startTime = prevState.startTime;
        state.score = prevState.score;
        
        updateUndoButton();
        render();
        updateScore(); // 更新分數顯示
    }
    
    function updateUndoButton() {
        document.getElementById('undo-btn').disabled = history.length <= 1;
    }

    function createGuaranteedDeck() {
        const baseDeck = [
            {suit: '♠', rank: 5, text: '5', color: 'black'},
            {suit: '♦', rank: 10, text: '10', color: 'red'},
            {suit: '♣', rank: 3, text: '3', color: 'black'},
            {suit: '♥', rank: 8, text: '8', color: 'red'},
            {suit: '♠', rank: 7, text: '7', color: 'black'},
            {suit: '♦', rank: 2, text: '2', color: 'red'},
            {suit: '♣', rank: 9, text: '9', color: 'black'},
            {suit: '♥', rank: 4, text: '4', color: 'red'},
            {suit: '♠', rank: 6, text: '6', color: 'black'},
            {suit: '♦', rank: 1, text: 'A', color: 'red'},
            {suit: '♣', rank: 11, text: 'J', color: 'black'},
            {suit: '♥', rank: 12, text: 'Q', color: 'red'},
            {suit: '♠', rank: 10, text: '10', color: 'black'},
            {suit: '♦', rank: 8, text: '8', color: 'red'},
            {suit: '♣', rank: 5, text: '5', color: 'black'},
            {suit: '♥', rank: 13, text: 'K', color: 'red'},
            {suit: '♠', rank: 3, text: '3', color: 'black'},
            {suit: '♦', rank: 6, text: '6', color: 'red'},
            {suit: '♣', rank: 12, text: 'Q', color: 'black'},
            {suit: '♥', rank: 9, text: '9', color: 'red'},
            {suit: '♠', rank: 1, text: 'A', color: 'black'},
            {suit: '♦', rank: 13, text: 'K', color: 'red'},
            {suit: '♣', rank: 8, text: '8', color: 'black'},
            {suit: '♥', rank: 7, text: '7', color: 'red'},
            {suit: '♠', rank: 12, text: 'Q', color: 'black'},
            {suit: '♦', rank: 4, text: '4', color: 'red'},
            {suit: '♣', rank: 1, text: 'A', color: 'black'},
            {suit: '♥', rank: 1, text: 'A', color: 'red'},
            {suit: '♠', rank: 9, text: '9', color: 'black'},
            {suit: '♦', rank: 3, text: '3', color: 'red'},
            {suit: '♣', rank: 10, text: '10', color: 'black'},
            {suit: '♥', rank: 5, text: '5', color: 'red'},
            {suit: '♠', rank: 2, text: '2', color: 'black'},
            {suit: '♦', rank: 5, text: '5', color: 'red'},
            {suit: '♣', rank: 7, text: '7', color: 'black'},
            {suit: '♥', rank: 11, text: 'J', color: 'red'},
            {suit: '♠', rank: 4, text: '4', color: 'black'},
            {suit: '♦', rank: 7, text: '7', color: 'red'},
            {suit: '♣', rank: 2, text: '2', color: 'black'},
            {suit: '♥', rank: 6, text: '6', color: 'red'},
            {suit: '♠', rank: 11, text: 'J', color: 'black'},
            {suit: '♦', rank: 9, text: '9', color: 'red'},
            {suit: '♣', rank: 4, text: '4', color: 'black'},
            {suit: '♥', rank: 10, text: '10', color: 'red'},
            {suit: '♠', rank: 13, text: 'K', color: 'black'},
            {suit: '♦', rank: 12, text: 'Q', color: 'red'},
            {suit: '♣', rank: 6, text: '6', color: 'black'},
            {suit: '♥', rank: 2, text: '2', color: 'red'},
            {suit: '♠', rank: 8, text: '8', color: 'black'},
            {suit: '♦', rank: 11, text: 'J', color: 'red'},
            {suit: '♣', rank: 13, text: 'K', color: 'black'},
            {suit: '♥', rank: 3, text: '3', color: 'red'}
        ];
        
        const deck = JSON.parse(JSON.stringify(baseDeck));
        const rotations = Math.floor(Math.random() * 10);
        for (let i = 0; i < rotations; i++) {
            deck.push(deck.shift());
        }
        return deck;
    }
    
    function showMessage(text, duration = 2000) {
        const messageEl = document.getElementById('message');
        messageEl.textContent = text;
        messageEl.style.display = 'block';
        setTimeout(() => {
            messageEl.style.display = 'none';
        }, duration);
    }
    
    // --- 提示系統 ---
    function showHint() {
        if (isAnimating) return;
        const hintBtn = document.getElementById('hint-btn');
        hintBtn.disabled = true;
        
        document.querySelectorAll('.highlight, .target-highlight').forEach(el => {
            el.classList.remove('highlight', 'target-highlight');
        });
        
        let hint = null;
        
        hint = findAceMove();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        hint = findFoundationMove();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        hint = findBestTableauMoveByUncoveredCards();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        hint = findBestTableauMoveByChainLength();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        if (state.waste.length > 0) {
            const wasteCard = state.waste[state.waste.length - 1];
            for (let j = 0; j < 4; j++) {
                const foundation = state.foundations[j];
                if (canMoveToFoundation(wasteCard, foundation)) {
                    showMessage(`提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到花色區${j+1}`, 2000);
                    let targetCardId = null;
                    if (foundation.length > 0) {
                        targetCardId = foundation[foundation.length - 1].id;
                    }
                    highlightCardPair(wasteCard.id, 'foundation', j, targetCardId);
                    setTimeout(() => { hintBtn.disabled = false; }, 500);
                    return;
                }
            }
            for (let targetCol = 0; targetCol < 7; targetCol++) {
                const targetPile = state.tableau[targetCol];
                if (canMoveToTableau(wasteCard, targetPile)) {
                    showMessage(`提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到第${targetCol+1}列`, 2000);
                    let targetCardId = null;
                    if (targetPile.length > 0) {
                        targetCardId = targetPile[targetPile.length - 1].id;
                    }
                    highlightCardPair(wasteCard.id, 'tableau', targetCol, targetCardId);
                    setTimeout(() => { hintBtn.disabled = false; }, 500);
                    return;
                }
            }
        }
        
        hint = findFlipCardHint();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCard(hint.cardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        if (state.stock.length > 0) {
            showMessage("提示：點擊牌堆來翻開新牌", 2000);
            highlightStock();
        } else if (state.waste.length > 0) {
            showMessage("提示：點擊廢牌堆左側的箭頭重新使用廢牌", 2000);
            highlightStock();
        } else {
            showMessage("嘗試移動不同的牌，或者重新開始遊戲", 2000);
        }
        
        setTimeout(() => { hintBtn.disabled = false; }, 500);
    }
    
    function findAceMove() {
        for (let i = 0; i < 7; i++) {
            const pile = state.tableau[i];
            if (pile.length === 0) continue;
            const topCard = pile[pile.length - 1];
            if (!topCard.faceUp) continue;
            if (topCard.rank === 1) {
                let alreadyInFoundation = false;
                for (let j = 0; j < 4; j++) {
                    const foundation = state.foundations[j];
                    if (foundation.length > 0 && foundation[0].suit === topCard.suit) {
                        alreadyInFoundation = true;
                        break;
                    }
                }
                if (!alreadyInFoundation) {
                    return {
                        message: `提示：將第${i+1}列的${topCard.text}${topCard.suit}移到花色區`,
                        sourceCardId: topCard.id,
                        targetType: 'foundation',
                        targetIdx: getEmptyFoundationIndex(),
                        targetCardId: null
                    };
                }
            }
        }
        if (state.waste.length > 0) {
            const wasteCard = state.waste[state.waste.length - 1];
            if (wasteCard.rank === 1) {
                let alreadyInFoundation = false;
                for (let j = 0; j < 4; j++) {
                    const foundation = state.foundations[j];
                    if (foundation.length > 0 && foundation[0].suit === wasteCard.suit) {
                        alreadyInFoundation = true;
                        break;
                    }
                }
                if (!alreadyInFoundation) {
                    return {
                        message: `提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到花色區`,
                        sourceCardId: wasteCard.id,
                        targetType: 'foundation',
                        targetIdx: getEmptyFoundationIndex(),
                        targetCardId: null
                    };
                }
            }
        }
        return null;
    }
    
    function getEmptyFoundationIndex() {
        for (let i = 0; i < 4; i++) {
            if (state.foundations[i].length === 0) return i;
        }
        return 0;
    }
    
    function findFoundationMove() {
        for (let i = 0; i < 7; i++) {
            const pile = state.tableau[i];
            if (pile.length === 0) continue;
            const topCard = pile[pile.length - 1];
            if (!topCard.faceUp) continue;
            for (let j = 0; j < 4; j++) {
                const foundation = state.foundations[j];
                if (canMoveToFoundation(topCard, foundation)) {
                    let targetCardId = null;
                    if (foundation.length > 0) targetCardId = foundation[foundation.length - 1].id;
                    return {
                        message: `提示：將第${i+1}列的${topCard.text}${topCard.suit}移到花色區${j+1}`,
                        sourceCardId: topCard.id,
                        targetType: 'foundation',
                        targetIdx: j,
                        targetCardId: targetCardId
                    };
                }
            }
        }
        if (state.waste.length > 0) {
            const wasteCard = state.waste[state.waste.length - 1];
            for (let j = 0; j < 4; j++) {
                const foundation = state.foundations[j];
                if (canMoveToFoundation(wasteCard, foundation)) {
                    let targetCardId = null;
                    if (foundation.length > 0) targetCardId = foundation[foundation.length - 1].id;
                    return {
                        message: `提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到花色區${j+1}`,
                        sourceCardId: wasteCard.id,
                        targetType: 'foundation',
                        targetIdx: j,
                        targetCardId: targetCardId
                    };
                }
            }
        }
        return null;
    }
    
    function findBestTableauMoveByUncoveredCards() {
        let bestMove = null;
        let bestUncoveredCount = -1;
        for (let sourceCol = 0; sourceCol < 7; sourceCol++) {
            const sourcePile = state.tableau[sourceCol];
            if (sourcePile.length === 0) continue;
            let sourceIdx = -1;
            for (let i = sourcePile.length - 1; i >= 0; i--) {
                if (sourcePile[i].faceUp) {
                    sourceIdx = i;
                    break;
                }
            }
            if (sourceIdx === -1) continue;
            const card = sourcePile[sourceIdx];
            for (let targetCol = 0; targetCol < 7; targetCol++) {
                if (sourceCol === targetCol) continue;
                const targetPile = state.tableau[targetCol];
                if (canMoveToTableau(card, targetPile)) {
                    let uncoveredCount = 0;
                    if (sourceIdx > 0 && !sourcePile[sourceIdx - 1].faceUp) uncoveredCount = 1;
                    if (uncoveredCount > bestUncoveredCount) {
                        bestUncoveredCount = uncoveredCount;
                        let targetCardId = null;
                        if (targetPile.length > 0) targetCardId = targetPile[targetPile.length - 1].id;
                        bestMove = {
                            sourceCol, targetCol, card,
                            message: `提示：將第${sourceCol+1}列的${card.text}${card.suit}移到第${targetCol+1}列`,
                            sourceCardId: card.id,
                            targetType: 'tableau',
                            targetIdx: targetCol,
                            targetCardId: targetCardId
                        };
                    }
                }
            }
        }
        return bestMove;
    }
    
    function findBestTableauMoveByChainLength() {
        let bestMove = null;
        let bestChainLength = -1;
        for (let sourceCol = 0; sourceCol < 7; sourceCol++) {
            const sourcePile = state.tableau[sourceCol];
            if (sourcePile.length === 0) continue;
            let sourceIdx = -1;
            for (let i = sourcePile.length - 1; i >= 0; i--) {
                if (sourcePile[i].faceUp) {
                    sourceIdx = i;
                    break;
                }
            }
            if (sourceIdx === -1) continue;
            const card = sourcePile[sourceIdx];
            const chainLength = sourcePile.length - sourceIdx;
            for (let targetCol = 0; targetCol < 7; targetCol++) {
                if (sourceCol === targetCol) continue;
                const targetPile = state.tableau[targetCol];
                if (canMoveToTableau(card, targetPile)) {
                    if (chainLength > bestChainLength) {
                        bestChainLength = chainLength;
                        let targetCardId = null;
                        if (targetPile.length > 0) targetCardId = targetPile[targetPile.length - 1].id;
                        bestMove = {
                            sourceCol, targetCol, card,
                            message: `提示：將第${sourceCol+1}列的${card.text}${card.suit}移到第${targetCol+1}列`,
                            sourceCardId: card.id,
                            targetType: 'tableau',
                            targetIdx: targetCol,
                            targetCardId: targetCardId
                        };
                    }
                }
            }
        }
        return bestMove;
    }
    
    function findFlipCardHint() {
        for (let i = 0; i < 7; i++) {
            const pile = state.tableau[i];
            if (pile.length > 0) {
                const topCard = pile[pile.length - 1];
                if (!topCard.faceUp) {
                    return {
                        message: `提示：點擊第${i+1}列最上面的蓋牌來翻牌`,
                        cardId: topCard.id
                    };
                }
            }
        }
        return null;
    }
    
    function highlightCard(cardId) {
        if (!cardId) return;
        const cardElement = document.querySelector(`[data-id="${cardId}"]`);
        if (cardElement) {
            cardElement.classList.add('highlight');
            setTimeout(() => { cardElement.classList.remove('highlight'); }, 2000);
        }
    }
    
    function highlightCardPair(sourceCardId, targetType, targetIdx, targetCardId = null) {
        const sourceElement = document.querySelector(`[data-id="${sourceCardId}"]`);
        if (sourceElement) {
            sourceElement.classList.add('highlight');
            setTimeout(() => { sourceElement.classList.remove('highlight'); }, 2000);
        }
        if (targetCardId) {
            const targetElement = document.querySelector(`[data-id="${targetCardId}"]`);
            if (targetElement) {
                targetElement.classList.add('target-highlight');
                setTimeout(() => { targetElement.classList.remove('target-highlight'); }, 2000);
            }
        } else if (targetType === 'foundation') {
            const foundationSlot = document.querySelector(`#slot-f${targetIdx}`);
            if (foundationSlot) {
                foundationSlot.classList.add('target-highlight');
                setTimeout(() => { foundationSlot.classList.remove('target-highlight'); }, 2000);
            }
        } else if (targetType === 'tableau') {
            const tableauSlot = document.querySelector(`#slot-t${targetIdx}`);
            if (tableauSlot) {
                tableauSlot.classList.add('target-highlight');
                setTimeout(() => { tableauSlot.classList.remove('target-highlight'); }, 2000);
            }
        }
    }
    
    function highlightStock() {
        const stockElement = document.querySelector('#slot-stock');
        if (stockElement) {
            stockElement.classList.add('highlight');
            setTimeout(() => { stockElement.classList.remove('highlight'); }, 2000);
        }
    }
    
    function canMoveToFoundation(card, foundation) {
        if (foundation.length === 0) return card.rank === 1;
        const topCard = foundation[foundation.length - 1];
        return card.suit === topCard.suit && card.rank === topCard.rank + 1;
    }
    
    function canMoveToTableau(card, tableauPile) {
        if (tableauPile.length === 0) return card.rank === 13;
        const topCard = tableauPile[tableauPile.length - 1];
        return card.color !== topCard.color && card.rank === topCard.rank - 1;
    }

    // --- 佈局計算 ---
    let slotPositions = {};
    let cardSize = {width: 0, height: 0};
    
    function layoutSlots() {
        const board = document.getElementById('game-board');
        const w = board.clientWidth;
        const measure = document.createElement('div');
        measure.className = 'slot';
        board.appendChild(measure);
        cardSize.width = measure.offsetWidth;
        cardSize.height = measure.offsetHeight;
        board.removeChild(measure);

        // 手機上確保卡片不會太大
        const isMobile = window.innerWidth < 600;
        if (isMobile) {
            // 限制手機上最大卡片尺寸
            const maxCardWidth = Math.min(cardSize.width, 70);
            const maxCardHeight = Math.min(cardSize.height, 98);
            cardSize.width = maxCardWidth;
            cardSize.height = maxCardHeight;
        }

        const gap = Math.max(1, (w - (cardSize.width * 7)) / 8);
        const setPos = (id, x, y) => {
            const el = document.getElementById(id);
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            slotPositions[id] = { 
                left: x, top: y, right: x + cardSize.width, bottom: y + cardSize.height,
                cx: x + cardSize.width/2, cy: y + cardSize.height/2
            };
        };

        // 上方區域佈局
        const topRowY = 10;
        setPos('slot-stock', gap, topRowY);
        setPos('slot-waste', gap*2 + cardSize.width, topRowY);
        
        // 四個花色區從右到左排列
        for(let i=0; i<4; i++) {
            setPos(`slot-f${i}`, w - gap*(4-i) - cardSize.width*(4-i), topRowY);
        }
        
        // 下方七列佈局
        const tableauY = topRowY + cardSize.height + (isMobile ? 15 : 30);
        for(let i=0; i<7; i++) {
            let x = gap * (i+1) + cardSize.width * i;
            setPos(`slot-t${i}`, x, tableauY);
        }
    }

    // --- 渲染引擎 ---
    function render() {
        const layer = document.getElementById('card-layer');
        layer.innerHTML = ''; 

        const drawCard = (card, x, y, type, pileIdx, cardIdx) => {
            const div = document.createElement('div');
            div.className = `card ${card.faceUp ? '' : 'back'}`;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.dataset.id = card.id;
            div.dataset.type = type;
            div.dataset.pileIdx = pileIdx;
            div.dataset.cardIdx = cardIdx;

            if (card.faceUp) {
                div.classList.add(card.color);
                div.innerHTML = `
                    <div class="card-face">
                        <div class="card-num ${card.color}">${card.text}</div>
                        <div class="card-suit-top ${card.color}">${card.suit}</div>
                        <div class="card-center-suit ${card.color}">${card.suit}</div>
                    </div>
                `;
                
                div.addEventListener('mousedown', (e) => startDrag(e, type, pileIdx, cardIdx));
                div.addEventListener('touchstart', (e) => startDrag(e, type, pileIdx, cardIdx), {passive: false});
                
            } else {
                if (type === 'stock') {
                    div.addEventListener('click', drawStock);
                } else if (type === 'tableau') {
                    const pile = state.tableau[pileIdx];
                    if (cardIdx === pile.length - 1) {
                        div.addEventListener('click', () => flipTableauCard(pileIdx));
                    }
                }
            }
            layer.appendChild(div);
        };

        const sPos = slotPositions['slot-stock'];
        if (state.stock.length > 0) {
            drawCard(state.stock[state.stock.length-1], sPos.left, sPos.top, 'stock', 0, 0);
        } else {
            const emptyStock = document.createElement('div');
            emptyStock.style.cssText = `position:absolute; left:${sPos.left}px; top:${sPos.top}px; width:${cardSize.width}px; height:${cardSize.height}px;`;
            emptyStock.innerHTML = '<div class="refresh-btn">↺</div>';
            emptyStock.addEventListener('click', resetStock);
            layer.appendChild(emptyStock);
        }

        const wPos = slotPositions['slot-waste'];
        const wasteLen = state.waste.length;
        if (wasteLen > 0) {
            const topWasteCard = state.waste[wasteLen - 1];
            drawCard(topWasteCard, wPos.left, wPos.top, 'waste', 0, wasteLen - 1);
        }

        for(let i=0; i<4; i++) {
            const pos = slotPositions[`slot-f${i}`];
            const pile = state.foundations[i];
            if (pile.length > 0) {
                drawCard(pile[pile.length-1], pos.left, pos.top, 'foundation', i, pile.length-1);
            }
        }

        for(let i=0; i<7; i++) {
            const pos = slotPositions[`slot-t${i}`];
            const pile = state.tableau[i];
            let currentOffset = 0;
            pile.forEach((card, idx) => {
                if (idx > 0) {
                    const prevCard = pile[idx - 1];
                    let overlapRatio = prevCard.faceUp ? (card.faceUp ? 0.7 : 0.9) : 0.9;
                    // 手機上減少重疊比例，讓更多牌可見
                    const isMobile = window.innerWidth < 600;
                    if (isMobile && card.faceUp) {
                        overlapRatio = 0.6;
                    }
                    currentOffset += cardSize.height * (1 - overlapRatio);
                }
                drawCard(card, pos.left, pos.top + currentOffset, 'tableau', i, idx);
            });
        }
    }
    
    function flipTableauCard(pileIdx) {
        if (isAnimating) return;
        const pile = state.tableau[pileIdx];
        if (pile.length > 0) {
            const topCard = pile[pile.length - 1];
            if (!topCard.faceUp) {
                topCard.faceUp = true;
                state.moves++;
                saveStateToHistory();
                render();
                updateTimer();
                updateScore(); // 更新分數
            }
        }
    }

    function drawStock() {
        if (isAnimating) return;
        if (state.stock.length === 0) return;
        const card = state.stock.pop();
        card.faceUp = true;
        state.waste.push(card);
        state.moves++;
        saveStateToHistory();
        render();
        updateTimer();
        updateScore(); // 更新分數
    }

    function resetStock() {
        if (isAnimating) return;
        if (state.waste.length === 0) return;
        state.stock = state.waste.reverse().map(c => { c.faceUp = false; return c; });
        state.waste = [];
        state.moves++;
        saveStateToHistory();
        render();
        updateTimer();
        updateScore(); // 更新分數
    }

    // --- 自動移動動畫函式 ---
    function animateMove(cards, sourceRect, targetRect, onComplete) {
        isAnimating = true;
        const ghosts = [];
        
        cards.forEach((card, i) => {
            const ghost = document.createElement('div');
            ghost.className = `card flying-card ${card.color}`;
            ghost.innerHTML = `
                <div class="card-face">
                    <div class="card-num ${card.color}">${card.text}</div>
                    <div class="card-suit-top ${card.color}">${card.suit}</div>
                    <div class="card-center-suit ${card.color}">${card.suit}</div>
                </div>
            `;
            
            // 計算堆疊偏移量
            const overlapRatio = 0.7;
            const overlapHeight = cardSize.height * overlapRatio;
            const offset = i * (cardSize.height - overlapHeight);

            // 初始位置
            ghost.style.left = sourceRect.left + 'px';
            ghost.style.top = (sourceRect.top + offset) + 'px';
            ghost.style.width = cardSize.width + 'px';
            ghost.style.height = cardSize.height + 'px';
            
            document.body.appendChild(ghost);
            ghosts.push(ghost);
        });

        // 強制瀏覽器 Reflow 以確保動畫發生
        void ghosts[0].offsetWidth;

        // 設定目標位置
        ghosts.forEach((ghost, i) => {
            const overlapRatio = 0.7; // 保持一致
            const overlapHeight = cardSize.height * overlapRatio;
            const offset = i * (cardSize.height - overlapHeight);
            
            ghost.style.left = targetRect.left + 'px';
            // Foundation 不需要堆疊偏移，但 Tableau 需要。
            // 這裡簡單處理：目標通常是堆疊的底部，我們往上疊
            // 若目標是 Tableau，計算正確的堆疊高度會很複雜，這裡簡化為飛到目標位置
            // 若要更精確，需要知道目標堆疊當前的 offset。
            // 為了視覺簡單，我們讓它飛到目標堆疊的「頂部」
            ghost.style.top = (targetRect.top + offset) + 'px';
        });

        // 動畫結束後清理
        setTimeout(() => {
            ghosts.forEach(g => g.remove());
            isAnimating = false;
            if (onComplete) onComplete();
        }, 300); // 配合 CSS transition 0.3s
    }

    // --- 雙擊自動移動邏輯 (包含動畫) ---
    function handleDoubleClick(type, pileIdx, cardIdx, cardId) {
        if (type === 'foundation') return;
        if (isAnimating) return;
        
        let sourcePile;
        let card;
        
        if (type === 'tableau') {
            sourcePile = state.tableau[pileIdx];
            if (cardIdx < 0 || cardIdx >= sourcePile.length) return;
            card = sourcePile[cardIdx];
            
            if (!card.faceUp) return;
            for (let i = cardIdx + 1; i < sourcePile.length; i++) {
                if (!sourcePile[i].faceUp) {
                    shakeCard(cardId);
                    return;
                }
            }
        } else if (type === 'waste') {
            sourcePile = state.waste;
            if (cardIdx !== sourcePile.length - 1) return;
            card = sourcePile[cardIdx];
        } else {
            return;
        }

        // 取得來源位置 (用於動畫)
        const cardEl = document.querySelector(`[data-id="${cardId}"]`);
        if (!cardEl) return;
        const sourceRect = cardEl.getBoundingClientRect();
        
        // 1. 嘗試移動到 Foundation
        for (let i = 0; i < 4; i++) {
            const foundation = state.foundations[i];
            if (canMoveToFoundation(card, foundation)) {
                // 取得目標位置
                const targetEl = document.getElementById(`slot-f${i}`);
                const targetRect = targetEl.getBoundingClientRect();
                
                // 準備移動數據
                const cardsToMove = (type === 'tableau') ? sourcePile.slice(cardIdx) : [sourcePile[sourcePile.length-1]];

                // 播放動畫
                animateMove(cardsToMove, sourceRect, targetRect, () => {
                    // 動畫結束後執行數據更新
                    if (type === 'tableau') {
                        sourcePile.splice(cardIdx);
                        foundation.push(...cardsToMove);
                        if (sourcePile.length > 0) sourcePile[sourcePile.length - 1].faceUp = true;
                    } else if (type === 'waste') {
                        foundation.push(sourcePile.pop());
                    }
                    
                    state.moves++;
                    saveStateToHistory();
                    render();
                    updateTimer();
                    updateScore(); // 更新分數
                    checkWin();
                });
                return; 
            }
        }
        
        // 2. 嘗試移動到 Tableau
        for (let targetIdx = 0; targetIdx < 7; targetIdx++) {
            if (type === 'tableau' && targetIdx === pileIdx) continue;
            const targetPile = state.tableau[targetIdx];
            
            if (card.rank === 13 && targetPile.length === 0 && type === 'tableau' && cardIdx === 0) continue; 

            if (canMoveToTableau(card, targetPile)) {
                // 取得目標位置 (如果有牌，飛到最後一張牌上；如果沒牌，飛到 slot 上)
                let targetRect;
                if (targetPile.length > 0) {
                    const topCardId = targetPile[targetPile.length-1].id;
                    const topCardEl = document.querySelector(`[data-id="${topCardId}"]`);
                    // Tableau 的牌是堆疊的，我們希望飛到下一張的位置
                    const rect = topCardEl.getBoundingClientRect();
                    targetRect = { 
                        left: rect.left, 
                        top: rect.top + (cardSize.height * 0.3) // 估算偏移量
                    };
                } else {
                    const slotEl = document.getElementById(`slot-t${targetIdx}`);
                    targetRect = slotEl.getBoundingClientRect();
                }

                const cardsToMove = (type === 'tableau') ? sourcePile.slice(cardIdx) : [sourcePile[sourcePile.length-1]];
                
                animateMove(cardsToMove, sourceRect, targetRect, () => {
                    if (type === 'tableau') {
                        sourcePile.splice(cardIdx);
                        targetPile.push(...cardsToMove);
                        if (sourcePile.length > 0) sourcePile[sourcePile.length - 1].faceUp = true;
                    } else if (type === 'waste') {
                        targetPile.push(sourcePile.pop());
                    }
                    
                    state.moves++;
                    saveStateToHistory();
                    render();
                    updateTimer();
                    updateScore(); // 更新分數
                    checkWin();
                });
                return;
            }
        }
        
        // 3. 失敗則震動
        shakeCard(cardId);
    }
    
    function shakeCard(cardId) {
        const cardElement = document.querySelector(`[data-id="${cardId}"]`);
        if (cardElement) {
            cardElement.classList.remove('shake');
            void cardElement.offsetWidth; // 強制重繪
            cardElement.classList.add('shake');
            setTimeout(() => { cardElement.classList.remove('shake'); }, 400);
        }
    }

    // --- 拖曳系統 ---
    function startDrag(e, type, pileIdx, cardIdx) {
        if (isAnimating) return; // 動畫中禁止拖曳
        e.stopPropagation();
        
        const now = Date.now();
        
        let sourcePile = (type === 'tableau') ? state.tableau[pileIdx] : (type === 'waste' ? state.waste : []);
        if (type === 'foundation') sourcePile = state.foundations[pileIdx];
        const clickedCard = sourcePile[cardIdx];
        if (!clickedCard) return;

        // 雙擊檢測
        if (clickedCard.id === lastClickCardId && now - lastClickTime < 350) {
            handleDoubleClick(type, pileIdx, cardIdx, clickedCard.id);
            lastClickCardId = null;
            lastClickTime = 0;
            return;
        }
        
        lastClickCardId = clickedCard.id;
        lastClickTime = now;

        if (drag.isDragging || drag.pending) return;

        if (!clickedCard.faceUp) return;
        if ((type === 'waste' || type === 'foundation') && cardIdx !== sourcePile.length - 1) return;
        
        drag.pending = true;
        drag.isDragging = false;
        
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        
        drag.startX = clientX;
        drag.startY = clientY;
        drag.origin = { type, pileIdx, cardIdx };
        
        drag.cards = [];
        if (type === 'tableau') {
            for (let i = cardIdx; i < sourcePile.length; i++) {
                drag.cards.push(sourcePile[i]);
            }
        } else {
            drag.cards.push(clickedCard);
        }

        const gameBoard = document.getElementById('game-board');
        drag.gameBoardRect = gameBoard.getBoundingClientRect();
        
        const cardEl = document.querySelector(`[data-id="${clickedCard.id}"]`);
        if (cardEl) {
            const rect = cardEl.getBoundingClientRect();
            drag.offset.x = clientX - rect.left;
            drag.offset.y = clientY - rect.top;
        }

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    }

    function createGhosts() {
        if (!drag.cards.length) return;
        
        const startCardEl = document.querySelector(`[data-id="${drag.cards[0].id}"]`);
        if (!startCardEl) return;
        const rect = startCardEl.getBoundingClientRect();

        drag.cards.forEach((card, i) => {
            const ghost = document.createElement('div');
            ghost.className = `card dragging-card ${card.color}`;
            ghost.innerHTML = `
                <div class="card-face">
                    <div class="card-num ${card.color}">${card.text}</div>
                    <div class="card-suit-top ${card.color}">${card.suit}</div>
                    <div class="card-center-suit ${card.color}">${card.suit}</div>
                </div>
            `;
            
            const overlapRatio = 0.7;
            const overlapHeight = cardSize.height * overlapRatio;
            const ghostOffset = i * (cardSize.height - overlapHeight);
            
            ghost.style.left = rect.left + 'px';
            ghost.style.top = (rect.top + ghostOffset) + 'px';
            ghost.style.width = rect.width + 'px';
            ghost.style.height = rect.height + 'px';
            
            document.body.appendChild(ghost);
            drag.elGhosts.push(ghost);
        });

        drag.cards.forEach(card => {
            const el = document.querySelector(`[data-id="${card.id}"]`);
            if (el) el.style.opacity = '0.3';
        });
    }

    function onDragMove(e) {
        if (!drag.pending && !drag.isDragging) return;
        
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        
        if (drag.pending) {
            const moveX = Math.abs(clientX - drag.startX);
            const moveY = Math.abs(clientY - drag.startY);
            
            if (moveX > 5 || moveY > 5) {
                drag.pending = false;
                drag.isDragging = true;
                createGhosts();
            } else {
                return;
            }
        }
        
        if (drag.isDragging) {
            if (e.cancelable) e.preventDefault();
            
            drag.elGhosts.forEach((el, i) => {
                const overlapRatio = 0.7;
                const overlapHeight = cardSize.height * overlapRatio;
                const ghostOffset = i * (cardSize.height - overlapHeight);
                el.style.left = (clientX - drag.offset.x) + 'px';
                el.style.top = (clientY - drag.offset.y + ghostOffset) + 'px';
            });
        }
    }

    function onDragEnd(e) {
        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);

        if (drag.pending) {
            drag.pending = false;
            return;
        }

        if (!drag.isDragging) return;

        const headGhost = drag.elGhosts[0];
        const ghostRect = headGhost.getBoundingClientRect();
        
        const ghostLeftRelative = ghostRect.left - drag.gameBoardRect.left;
        const ghostTopRelative = ghostRect.top - drag.gameBoardRect.top;
        const ghostCenterX = ghostLeftRelative + ghostRect.width / 2;
        const ghostCenterY = ghostTopRelative + ghostRect.height / 2;

        let target = null;
        
        for (let i = 0; i < 4; i++) {
            const s = slotPositions[`slot-f${i}`];
            if (!s) continue;
            if (ghostCenterX >= s.left && ghostCenterX <= s.right && 
                ghostCenterY >= s.top && ghostCenterY <= s.bottom + 50) {
                target = { type: 'foundation', idx: i };
                break;
            }
        }
        
        if (!target) {
            for (let i = 0; i < 7; i++) {
                const s = slotPositions[`slot-t${i}`];
                if (!s) continue;
                if (ghostCenterX >= s.left - 30 && ghostCenterX <= s.right + 30 && 
                    ghostCenterY >= s.top - 50) {
                    target = { type: 'tableau', idx: i };
                    break;
                }
            }
        }

        let success = false;
        if (target) {
            success = tryMove(drag.cards, drag.origin, target);
        }

        drag.elGhosts.forEach(el => el.remove());
        drag.elGhosts = [];
        drag.isDragging = false;
        
        drag.cards.forEach(card => {
            const el = document.querySelector(`[data-id="${card.id}"]`);
            if (el) el.style.opacity = '1';
        });

        if (success) {
            state.moves++;
            saveStateToHistory();
            render();
            updateTimer();
            updateScore(); // 更新分數
            checkWin();
        } else {
            render();
        }
    }

    function tryMove(cards, source, target) {
        if (!cards || cards.length === 0) return false;
        const moveCard = cards[0];
        
        if (target.type === 'foundation') {
            if (cards.length > 1) return false;
            const foundation = state.foundations[target.idx];
            if (foundation.length === 0) {
                if (moveCard.rank !== 1) return false;
            } else {
                const topCard = foundation[foundation.length - 1];
                if (moveCard.suit !== topCard.suit || moveCard.rank !== topCard.rank + 1) return false;
            }
            performMove(source, target, cards);
            return true;
        }
        
        if (target.type === 'tableau') {
            if (source.type === 'tableau' && source.pileIdx === target.idx) return false;
            const tableau = state.tableau[target.idx];
            if (tableau.length === 0) {
                if (moveCard.rank !== 13) return false;
            } else {
                const topCard = tableau[tableau.length - 1];
                if (moveCard.color === topCard.color || moveCard.rank !== topCard.rank - 1) return false;
            }
            performMove(source, target, cards);
            return true;
        }
        return false;
    }

    function performMove(source, target, cards) {
        if (source.type === 'waste') {
            state.waste.splice(source.cardIdx, 1);
        } else if (source.type === 'tableau') {
            state.tableau[source.pileIdx].splice(source.cardIdx, cards.length);
            if (state.tableau[source.pileIdx].length > 0) {
                state.tableau[source.pileIdx][state.tableau[source.pileIdx].length - 1].faceUp = true;
            }
        } else if (source.type === 'foundation') {
            state.foundations[source.pileIdx].splice(source.cardIdx, 1);
        }
        
        if (target.type === 'foundation') {
            state.foundations[target.idx].push(...cards);
        } else if (target.type === 'tableau') {
            state.tableau[target.idx].push(...cards);
        }
    }

    function checkWin() {
        let totalCards = 0;
        state.foundations.forEach(pile => totalCards += pile.length);
        if (totalCards === 52) {
            stopTimer();
            // 計算最終分數
            updateScore();
            setTimeout(() => {
                alert(`🎉 恭喜破關！ 🎉\n移動次數：${state.moves}\n最終分數：${state.score}`);
            }, 200);
        }
    }

    window.addEventListener('load', () => {
        initGame('guaranteed');
        window.addEventListener('resize', layoutSlots);
    });
    
    // 防止手機雙指縮放
    document.addEventListener('gesturestart', function (e) {
        e.preventDefault();
    });
</script>
</body>
</html>