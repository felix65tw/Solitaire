<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>經典接龍 (手機適配版)</title>
    <style>
        /* CSS 變數定義，方便全域調整樣式 */
        :root {
            --bg-color: #35654d; /* 遊戲背景顏色 */
            --card-width: 13vw; /* 卡片預設寬度 (視窗寬度百分比) */
            --card-height: 18.2vw; /* 卡片預設高度 (視窗寬度百分比) */
            --max-w: 100px; /* 卡片最大寬度 */
            --max-h: 140px; /* 卡片最大高度 */
            --gap: 2vw; /* 卡片間距 */
        }

        /* 全域樣式設定 */
        body {
            background-color: var(--bg-color); /* 使用CSS變數設定背景色 */
            margin: 0;
            overflow: hidden; /* 隱藏滾動條 */
            user-select: none; /* 禁止文字選取 */
            font-family: sans-serif; /* 字型設定 */
            -webkit-tap-highlight-color: transparent; /* 移除移動端點擊高亮 */
            touch-action: manipulation; /* 改善觸控響應 */
        }

        /* 工具欄樣式 */
        .toolbar {
            height: 50px; /* 工具欄高度 */
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px; /* 手機上減少padding */
            color: white;
            background: rgba(0,0,0,0.2); /* 半透明黑色背景 */
        }
        
        /* 工具欄左側區塊 */
        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 10px; /* 元素間距 */
        }
        
        /* 工具欄標題 */
        .toolbar-title {
            font-size: 14px; /* 手機上字體小一點 */
            white-space: nowrap; /* 不換行 */
            overflow: hidden; /* 隱藏溢出內容 */
            text-overflow: ellipsis; /* 文字溢出顯示省略號 */
        }
        
        /* 分數顯示 */
        .score-display {
            font-size: 14px;
            font-weight: bold;
            color: #FFD700; /* 金色文字 */
            padding: 2px 8px;
            background: rgba(0,0,0,0.3); /* 半透明背景 */
            border-radius: 10px; /* 圓角 */
            min-width: 60px;
            text-align: center;
        }
        
        /* 工具欄按鈕區塊 */
        .toolbar-buttons {
            display: flex;
            gap: 5px; /* 手機上按鈕間距小一點 */
        }
        
        /* 按鈕基礎樣式 */
        button {
            background: white;
            border: none;
            padding: 6px 10px; /* 手機上按鈕小一點 */
            border-radius: 4px; /* 圓角 */
            font-weight: bold;
            cursor: pointer; /* 游標手形 */
            font-size: 12px; /* 手機上字體小一點 */
            white-space: nowrap; /* 不換行 */
        }
        
        /* 按鈕懸停效果 */
        button:hover {
            background: #f0f0f0;
        }
        
        /* 禁用按鈕樣式 */
        button:disabled {
            background: #cccccc;
            cursor: not-allowed; /* 禁用游標 */
        }
        
        /* 訊息提示框 */
        #message {
            position: fixed; /* 固定定位 */
            top: 60px;
            left: 50%;
            transform: translateX(-50%); /* 水平居中 */
            background: rgba(0,0,0,0.8); /* 半透明黑色背景 */
            color: white;
            padding: 10px 20px;
            border-radius: 5px; /* 圓角 */
            z-index: 10000; /* 確保在最上層 */
            display: none; /* 預設隱藏 */
            font-size: 14px;
            max-width: 90%; /* 最大寬度 */
            text-align: center; /* 文字居中 */
        }

        /* 遊戲主區域 */
        #game-board {
            position: relative; /* 相對定位 */
            width: 100vw; /* 全視窗寬度 */
            height: calc(100vh - 50px); /* 減去工具欄高度 */
            max-width: 800px; /* 最大寬度限制 */
            margin: 0 auto; /* 水平居中 */
            margin-top: 5px; /* 手機上減少上邊距 */
            overflow: hidden; /* 防止溢出 */
        }

        /* 卡片位置槽位 */
        .slot {
            position: absolute; /* 絕對定位 */
            width: var(--card-width); /* 使用CSS變數設定寬度 */
            height: var(--card-height); /* 使用CSS變數設定高度 */
            max-width: var(--max-w); /* 最大寬度限制 */
            max-height: var(--max-h); /* 最大高度限制 */
            border: 2px solid rgba(255,255,255,0.2); /* 半透明邊框 */
            border-radius: 8px; /* 圓角 */
            box-sizing: border-box; /* 盒模型設定 */
        }

        /* 卡片基礎樣式 */
        .card {
            position: absolute; /* 絕對定位 */
            width: var(--card-width); /* 使用CSS變數設定寬度 */
            height: var(--card-height); /* 使用CSS變數設定高度 */
            max-width: var(--max-w); /* 最大寬度限制 */
            max-height: var(--max-h); /* 最大高度限制 */
            background-color: white; /* 白色背景 */
            border-radius: 6px; /* 圓角 */
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4); /* 陰影效果 */
            display: flex;
            justify-content: center; /* 水平居中 */
            align-items: center; /* 垂直居中 */
            z-index: 10; /* 圖層順序 */
            cursor: pointer; /* 游標手形 */
            box-sizing: border-box; /* 盒模型設定 */
            transition: box-shadow 0.2s; /* 陰影過渡效果 */
            -webkit-user-drag: none; /* 防止拖曳圖片 */
        }

        /* 用於自動移動時的飛行卡片 */
        .flying-card {
            position: fixed; /* 固定定位 */
            z-index: 99999; /* 最高圖層 */
            pointer-events: none; /* 禁止觸發事件 */
            transition: all 0.3s ease-in-out; /* 過渡動畫 */
        }

        /* 卡片面 */
        .card-face {
            width: 100%;
            height: 100%;
            position: relative; /* 相對定位 */
            pointer-events: none; /* 禁止觸發事件 */
        }

        /* 左上角數字 */
        .card-num { 
            font-size: 1.8rem; 
            font-weight: 800; 
            line-height: 1;
            position: absolute;
            top: 4px; /* 減少上邊距 */
            left: 4px; /* 減少左邊距 */
        }
        
        /* 右上角花色 */
        .card-suit-top { 
            font-size: 1.8rem; 
            line-height: 1; 
            position: absolute;
            top: 4px; /* 減少上邊距 */
            right: 4px; /* 減少右邊距 */
        }
        
        /* 卡片中間的大花色 */
        .card-center-suit {
            position: absolute;
            top: 62%; /* 原本是 50%，改成 62% 往下移 */
            left: 50%;
            transform: translate(-50%, -50%); /* 居中對齊 */
            font-size: 4rem;
            font-weight: normal;
        }
        
        /* 紅色花色 */
        .red { color: #d32f2f; }
        /* 黑色花色 */
        .black { color: #212121; }

        /* 卡片背面樣式 */
        .back {
            background: repeating-linear-gradient( /* 重複線性漸變 */
                45deg, /* 45度角 */
                #1565c0, /* 顏色1 */
                #1565c0 10px, /* 顏色1結束位置 */
                #0d47a1 10px, /* 顏色2開始位置 */
                #0d47a1 20px /* 顏色2結束位置 */
            );
            border: 2px solid #fff; /* 白色邊框 */
        }

        /* 拖曳中的卡片 */
        .dragging-card {
            position: fixed; /* 固定定位 */
            z-index: 9999; /* 高圖層 */
            pointer-events: none; /* 禁止觸發事件 */
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5); /* 更明顯的陰影 */
            opacity: 0.9; /* 半透明 */
        }

        /* 重新整理按鈕 */
        .refresh-btn {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; color: rgba(255,255,255,0.5);
            cursor: pointer;
        }

        /* 高光效果：增加 pointer-events: none 防止擋住點擊 */
        .highlight {
            animation: yellowPulse 0.8s infinite alternate; /* 動畫效果 */
            box-shadow: 0 0 0 4px #FFEB3B, 0 0 20px 8px #FFEB3B !important;
            border: 2px solid #FFEB3B !important;
            z-index: 1000;
            pointer-events: none; /* 關鍵修復：讓點擊穿透高光框 */
        }

        /* 目標高光效果 */
        .target-highlight {
            animation: targetPulse 0.8s infinite alternate;
            box-shadow: 0 0 0 4px #4CAF50, 0 0 20px 8px #4CAF50 !important;
            border: 2px solid #4CAF50 !important;
            z-index: 999;
            pointer-events: none; /* 關鍵修復 */
        }

        /* 黃色脈衝動畫 */
        @keyframes yellowPulse {
            0% { box-shadow: 0 0 0 4px #FFEB3B, 0 0 20px 8px #FFEB3B !important; transform: scale(1.02); }
            100% { box-shadow: 0 0 0 6px #FFEB3B, 0 0 30px 12px #FFEB3B !important; transform: scale(1.05); }
        }

        /* 綠色脈衝動畫 */
        @keyframes targetPulse {
            0% { box-shadow: 0 0 0 4px #4CAF50, 0 0 20px 8px #4CAF50 !important; transform: scale(1.02); }
            100% { box-shadow: 0 0 0 6px #4CAF50, 0 0 30px 12px #4CAF50 !important; transform: scale(1.05); }
        }

        /* 抖動動畫 */
        .shake {
            animation: shake 0.4s ease-in-out;
        }

        /* 抖動動畫關鍵影格 */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            16% { transform: translateX(-6px); }
            33% { transform: translateX(6px); }
            50% { transform: translateX(-6px); }
            66% { transform: translateX(6px); }
            83% { transform: translateX(-6px); }
        }

        /* 桌面版樣式 - 維持原始文字和花色大小 */
        @media (min-width: 600px) {
            :root {
                --card-width: 80px; /* 桌面版固定寬度 */
                --card-height: 112px; /* 桌面版固定高度 */
                --gap: 15px; /* 桌面版固定間距 */
            }
            
            /* 桌面版保持原始大小 */
            .card-num, .card-suit-top { font-size: 1.8rem; }
            .card-center-suit { font-size: 4rem; }
            
            .toolbar {
                padding: 0 20px; /* 桌面版增加padding */
            }
            
            .toolbar-title {
                font-size: 16px; /* 桌面版字體稍大 */
            }
            
            .toolbar-buttons {
                gap: 10px; /* 桌面版按鈕間距稍大 */
            }
            
            button {
                padding: 8px 16px; /* 桌面版按鈕稍大 */
                font-size: 14px; /* 桌面版字體稍大 */
            }
            
            .score-display {
                font-size: 16px; /* 桌面版字體稍大 */
                padding: 4px 12px; /* 桌面版padding稍大 */
            }
        }

        /* 手機版專用樣式 - 已調整 */
        @media (max-width: 599px) {
            :root {
                --card-width: 12.5vw; /* 卡片寬度 (從11vw增加) */
                --card-height: 17.5vw; /* 卡片高度 (從15.4vw增加) */
                --gap: 1vw; /* 縮小牌間距 (從1.5vw減少) */
            }
            
            /* 手機上卡片字體調整 */
            .card-num { 
                font-size: 2.5rem; /* 調整為2.5rem (從3rem減少) */
                font-weight: 800;
                position: absolute;
                top: 1.3px; /* 修改：改為1.3px (從2px調整) */
                left: 1.3px; /* 修改：改為1.3px (從2px調整) */
                line-height: 1;
            }
            
            .card-suit-top {
                font-size: 1.1rem; /* 維持1.1rem不變 */
                position: absolute;
                top: 2px; /* 修改：改為1.3px (從2px調整) */
                right: 1.3px; /* 修改：改為1.3px (從2px調整) */
                line-height: 1;
            }
            
            /* 手機上中間花色調整 */
            .card-center-suit { 
                font-size: 2.2rem; /* 從2.2rem增加到2.5rem */
                position: absolute;
                /* 修改：移除top屬性，改用bottom讓花色靠近底部 */
                top: 25px; /* 修改：使用bottom屬性，離底端1.1px */
                left: 50%;
                transform: translateX(-50%); /* 修改：只水平居中，垂直居中由bottom控制 */
                font-weight: normal;
            }
            
            /* 手機上工具欄調整 */
            .toolbar {
                height: 45px; /* 手機版工具欄稍矮 */
                padding: 0 8px; /* 手機版padding稍小 */
            }
            
            .toolbar-title {
                font-size: 12px; /* 手機版字體稍小 */
                max-width: 30%; /* 最大寬度限制 */
            }
            
            .toolbar-buttons {
                gap: 4px; /* 手機版按鈕間距稍小 */
            }
            
            button {
                padding: 5px 8px; /* 手機版按鈕稍小 */
                font-size: 11px; /* 手機版字體稍小 */
                border-radius: 3px; /* 手機版圓角稍小 */
            }
            
            .score-display {
                font-size: 12px; /* 手機版字體稍小 */
                padding: 2px 6px; /* 手機版padding稍小 */
                min-width: 50px; /* 最小寬度 */
            }
            
            #game-board {
                height: calc(100vh - 45px); /* 減去工具欄高度 */
                margin-top: 3px; /* 手機版上邊距稍小 */
            }
            
            /* 手機上訊息框調整 */
            #message {
                font-size: 12px; /* 手機版字體稍小 */
                padding: 8px 15px; /* 手機版padding稍小 */
                top: 50px; /* 調整位置 */
                max-width: 95%; /* 最大寬度限制 */
            }
            
            /* 特別小的手機 */
            @media (max-width: 320px) {
                :root {
                    --card-width: 12vw; /* 稍微調整 */
                    --card-height: 16.8vw; /* 等比例調整 */
                    --gap: 0.8vw; /* 更小的間距 */
                }
                
                .toolbar-title {
                    font-size: 11px; /* 更小的字體 */
                }
                
                button {
                    padding: 4px 6px; /* 更小的按鈕 */
                    font-size: 10px; /* 更小的字體 */
                }
                
                .score-display {
                    font-size: 11px; /* 更小的字體 */
                }
                
                /* 在特別小的屏幕上進一步調整卡片字體 */
                .card-num { 
                    font-size: 2.2rem; /* 比2.5rem稍小一點 */
                    top: 1.3px; /* 保持1.3px邊距 */
                    left: 1.3px; /* 保持1.3px邊距 */
                }
                
                .card-suit-top {
                    font-size: 1rem; /* 比1.1rem稍小一點 */
                    top: 1.3px; /* 保持1.3px邊距 */
                    right: 1.3px; /* 保持1.3px邊距 */
                }
                
                .card-center-suit { 
                    font-size: 2.2rem; /* 從2rem增加到2.2rem */
                    bottom: 1.1px; /* 保持離底端1.1px */
                }
            }
        }
        /* 注意：已移除所有橫屏模式的媒體查詢，本遊戲只支持豎屏模式 */
    </style>
</head>
<body>

<!-- 工具欄區塊 -->
<div class="toolbar">
    <div class="toolbar-left">
        <span class="toolbar-title">經典接龍</span>
        <div class="score-display">分數: <span id="current-score">1000</span></div>
    </div>
    <div class="toolbar-buttons">
        <button onclick="initGame('guaranteed')" id="new-game-btn">新牌局</button>
        <button onclick="undoMove()" id="undo-btn" disabled>撤回</button>
        <button onclick="showHint()" id="hint-btn">提示</button>
    </div>
</div>

<!-- 訊息提示框 -->
<div id="message"></div>

<!-- 遊戲主區域 -->
<div id="game-board">
    <!-- 牌堆槽位 -->
    <div id="slot-stock" class="slot"></div>
    <!-- 廢牌堆槽位 -->
    <div id="slot-waste" class="slot"></div>
    <!-- 四個花色區槽位 -->
    <div id="slot-f0" class="slot" data-type="foundation" data-idx="0"></div>
    <div id="slot-f1" class="slot" data-type="foundation" data-idx="1"></div>
    <div id="slot-f2" class="slot" data-type="foundation" data-idx="2"></div>
    <div id="slot-f3" class="slot" data-type="foundation" data-idx="3"></div>

    <!-- 七列表格槽位 -->
    <div id="slot-t0" class="slot" data-type="tableau" data-idx="0"></div>
    <div id="slot-t1" class="slot" data-type="tableau" data-idx="1"></div>
    <div id="slot-t2" class="slot" data-type="tableau" data-idx="2"></div>
    <div id="slot-t3" class="slot" data-type="tableau" data-idx="3"></div>
    <div id="slot-t4" class="slot" data-type="tableau" data-idx="4"></div>
    <div id="slot-t5" class="slot" data-type="tableau" data-idx="5"></div>
    <div id="slot-t6" class="slot" data-type="tableau" data-idx="6"></div>

    <!-- 卡片圖層 -->
    <div id="card-layer"></div>
</div>

<script>
    // ==================== 遊戲常數定義 ====================
    const SUITS = ['♠', '♥', '♣', '♦']; // 花色陣列
    const COLORS = { '♠': 'black', '♥': 'red', '♣': 'black', '♦': 'red' }; // 花色對應顏色
    const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K']; // 牌面值陣列

    // ==================== 遊戲狀態變數 ====================
    let state = {
        stock: [], // 牌堆
        waste: [], // 廢牌堆
        foundations: [[], [], [], []], // 四個花色區
        tableau: [[], [], [], [], [], [], []], // 七列表格
        gameMode: 'guaranteed', // 遊戲模式
        moves: 0, // 移動次數
        startTime: null, // 遊戲開始時間
        timerInterval: null, // 計時器間隔ID
        score: 1000 // 初始分數
    };
    
    let history = []; // 遊戲歷史紀錄，用於撤回功能

    // ==================== 拖曳相關變數 ====================
    let drag = {
        isDragging: false, // 是否正在拖曳
        pending: false, // 是否等待拖曳開始
        startX: 0, // 拖曳起始X座標
        startY: 0, // 拖曳起始Y座標
        cards: [], // 拖曳中的卡片陣列
        origin: null, // 拖曳來源資訊
        elGhosts: [], // 拖曳時的幽靈卡片元素陣列
        offset: {x:0, y:0}, // 滑鼠/手指與卡片的偏移量
        gameBoardRect: null // 遊戲區域的邊界資訊
    };
    
    // 雙擊與動畫控制變數
    let lastClickTime = 0; // 上次點擊時間
    let lastClickCardId = null; // 上次點擊的卡片ID
    let isAnimating = false; // 是否正在執行動畫，防止動畫期間重複操作
    
    // ==================== 分數計算與更新函數 ====================
    /**
     * 更新遊戲分數
     * 分數計算公式：基礎分數1000 + 時間獎勵 + 步數獎勵
     */
    function updateScore() {
        // 計算經過的時間
        const elapsed = state.startTime ? Date.now() - state.startTime : 0;
        // 時間獎勵：每10秒減少10分，最低為0
        const timeBonus = Math.max(0, 600 - Math.floor(elapsed / 10000)) * 10;
        // 步數獎勵：每步5分，最多100步
        const movesBonus = Math.max(0, 100 - state.moves) * 5;
        // 計算總分數
        state.score = 1000 + timeBonus + movesBonus;
        
        // 更新顯示
        document.getElementById('current-score').textContent = state.score;
    }
    
    // ==================== 計時器相關函數 ====================
    /**
     * 開始計時器
     */
    function startTimer() {
        if (state.timerInterval) clearInterval(state.timerInterval); // 清除現有計時器
        state.startTime = Date.now(); // 記錄開始時間
        updateScore(); // 初始化分數
        state.timerInterval = setInterval(updateTimer, 1000); // 每秒更新一次
    }
    
    /**
     * 更新計時器顯示
     */
    function updateTimer() {
        if (!state.startTime) return;
        
        // 計算經過的時間
        const elapsed = Date.now() - state.startTime;
        const minutes = Math.floor(elapsed / 60000); // 計算分鐘
        const seconds = Math.floor((elapsed % 60000) / 1000); // 計算秒數
        
        // 更新工具欄標題
        const timerElement = document.querySelector('.toolbar-title');
        if (timerElement) {
            timerElement.textContent = `接龍 | ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')} | ${state.moves}步`;
        }
        
        // 更新分數
        updateScore();
    }
    
    /**
     * 停止計時器
     */
    function stopTimer() {
        if (state.timerInterval) {
            clearInterval(state.timerInterval);
            state.timerInterval = null;
        }
    }

    // ==================== 遊戲初始化函數 ====================
    /**
     * 初始化遊戲
     * @param {string} mode - 遊戲模式
     */
    function initGame(mode = 'guaranteed') {
        stopTimer(); // 停止計時器
        state.gameMode = mode; // 設定遊戲模式
        state.moves = 0; // 重置移動次數
        state.score = 1000; // 重置分數
        history = []; // 清空歷史紀錄
        updateUndoButton(); // 更新撤回按鈕狀態
        
        let deck = []; // 牌組
        if (mode === 'guaranteed') {
            showMessage("新牌局開始！", 2000); // 顯示開始訊息
            deck = createGuaranteedDeck(); // 建立保證可解的牌組
        }

        // 重置遊戲狀態
        state.stock = [];
        state.waste = [];
        state.foundations = [[], [], [], []];
        state.tableau = [[], [], [], [], [], [], []];

        // 發牌到七列表格
        for (let i = 0; i < 7; i++) {
            for (let j = i; j < 7; j++) {
                if (deck.length === 0) break;
                let card = deck.pop(); // 從牌組取牌
                card.id = Math.random().toString(36).substr(2,9); // 產生唯一ID
                card.faceUp = (i === j); // 只有每列最後一張牌面朝上
                state.tableau[j].push(card); // 放入表格
            }
        }

        // 剩餘牌放入牌堆
        state.stock = deck.reverse(); // 反轉牌組順序
        state.stock.forEach(card => {
            card.id = Math.random().toString(36).substr(2,9); // 產生唯一ID
            card.faceUp = false; // 牌堆中的牌面朝下
        });
        
        saveStateToHistory(); // 儲存初始狀態到歷史紀錄
        layoutSlots(); // 佈局槽位
        render(); // 渲染遊戲畫面
        startTimer(); // 開始計時
    }
    
    // ==================== 歷史紀錄相關函數 ====================
    /**
     * 儲存當前遊戲狀態到歷史紀錄
     */
    function saveStateToHistory() {
        const stateCopy = {
            stock: JSON.parse(JSON.stringify(state.stock)), // 深拷貝牌堆
            waste: JSON.parse(JSON.stringify(state.waste)), // 深拷貝廢牌堆
            foundations: JSON.parse(JSON.stringify(state.foundations)), // 深拷貝花色區
            tableau: JSON.parse(JSON.stringify(state.tableau)), // 深拷貝表格
            moves: state.moves, // 移動次數
            gameMode: state.gameMode, // 遊戲模式
            startTime: state.startTime, // 開始時間
            score: state.score // 分數
        };
        history.push(stateCopy); // 加入歷史紀錄
        updateUndoButton(); // 更新撤回按鈕狀態
    }
    
    /**
     * 撤回上一步移動
     */
    function undoMove() {
        if (isAnimating) return; // 動畫中禁止撤回
        if (history.length <= 1) return; // 沒有歷史紀錄可撤回
        history.pop(); // 移除當前狀態
        const prevState = history[history.length - 1]; // 取得上一個狀態
        
        // 恢復上一個狀態
        state.stock = JSON.parse(JSON.stringify(prevState.stock));
        state.waste = JSON.parse(JSON.stringify(prevState.waste));
        state.foundations = JSON.parse(JSON.stringify(prevState.foundations));
        state.tableau = JSON.parse(JSON.stringify(prevState.tableau));
        state.moves = prevState.moves;
        state.gameMode = prevState.gameMode;
        state.startTime = prevState.startTime;
        state.score = prevState.score;
        
        updateUndoButton(); // 更新撤回按鈕狀態
        render(); // 重新渲染
        updateScore(); // 更新分數顯示
    }
    
    /**
     * 更新撤回按鈕狀態
     */
    function updateUndoButton() {
        document.getElementById('undo-btn').disabled = history.length <= 1;
    }

    // ==================== 牌組建立函數 ====================
    /**
     * 建立保證可解的牌組
     * @returns {Array} - 牌組陣列
     */
    function createGuaranteedDeck() {
        // 基礎牌組，保證可解
        const baseDeck = [
            {suit: '♠', rank: 5, text: '5', color: 'black'},
            {suit: '♦', rank: 10, text: '10', color: 'red'},
            {suit: '♣', rank: 3, text: '3', color: 'black'},
            {suit: '♥', rank: 8, text: '8', color: 'red'},
            {suit: '♠', rank: 7, text: '7', color: 'black'},
            {suit: '♦', rank: 2, text: '2', color: 'red'},
            {suit: '♣', rank: 9, text: '9', color: 'black'},
            {suit: '♥', rank: 4, text: '4', color: 'red'},
            {suit: '♠', rank: 6, text: '6', color: 'black'},
            {suit: '♦', rank: 1, text: 'A', color: 'red'},
            {suit: '♣', rank: 11, text: 'J', color: 'black'},
            {suit: '♥', rank: 12, text: 'Q', color: 'red'},
            {suit: '♠', rank: 10, text: '10', color: 'black'},
            {suit: '♦', rank: 8, text: '8', color: 'red'},
            {suit: '♣', rank: 5, text: '5', color: 'black'},
            {suit: '♥', rank: 13, text: 'K', color: 'red'},
            {suit: '♠', rank: 3, text: '3', color: 'black'},
            {suit: '♦', rank: 6, text: '6', color: 'red'},
            {suit: '♣', rank: 12, text: 'Q', color: 'black'},
            {suit: '♥', rank: 9, text: '9', color: 'red'},
            {suit: '♠', rank: 1, text: 'A', color: 'black'},
            {suit: '♦', rank: 13, text: 'K', color: 'red'},
            {suit: '♣', rank: 8, text: '8', color: 'black'},
            {suit: '♥', rank: 7, text: '7', color: 'red'},
            {suit: '♠', rank: 12, text: 'Q', color: 'black'},
            {suit: '♦', rank: 4, text: '4', color: 'red'},
            {suit: '♣', rank: 1, text: 'A', color: 'black'},
            {suit: '♥', rank: 1, text: 'A', color: 'red'},
            {suit: '♠', rank: 9, text: '9', color: 'black'},
            {suit: '♦', rank: 3, text: '3', color: 'red'},
            {suit: '♣', rank: 10, text: '10', color: 'black'},
            {suit: '♥', rank: 5, text: '5', color: 'red'},
            {suit: '♠', rank: 2, text: '2', color: 'black'},
            {suit: '♦', rank: 5, text: '5', color: 'red'},
            {suit: '♣', rank: 7, text: '7', color: 'black'},
            {suit: '♥', rank: 11, text: 'J', color: 'red'},
            {suit: '♠', rank: 4, text: '4', color: 'black'},
            {suit: '♦', rank: 7, text: '7', color: 'red'},
            {suit: '♣', rank: 2, text: '2', color: 'black'},
            {suit: '♥', rank: 6, text: '6', color: 'red'},
            {suit: '♠', rank: 11, text: 'J', color: 'black'},
            {suit: '♦', rank: 9, text: '9', color: 'red'},
            {suit: '♣', rank: 4, text: '4', color: 'black'},
            {suit: '♥', rank: 10, text: '10', color: 'red'},
            {suit: '♠', rank: 13, text: 'K', color: 'black'},
            {suit: '♦', rank: 12, text: 'Q', color: 'red'},
            {suit: '♣', rank: 6, text: '6', color: 'black'},
            {suit: '♥', rank: 2, text: '2', color: 'red'},
            {suit: '♠', rank: 8, text: '8', color: 'black'},
            {suit: '♦', rank: 11, text: 'J', color: 'red'},
            {suit: '♣', rank: 13, text: 'K', color: 'black'},
            {suit: '♥', rank: 3, text: '3', color: 'red'}
        ];
        
        const deck = JSON.parse(JSON.stringify(baseDeck)); // 深拷貝基礎牌組
        const rotations = Math.floor(Math.random() * 10); // 隨機旋轉次數
        for (let i = 0; i < rotations; i++) {
            deck.push(deck.shift()); // 旋轉牌組
        }
        return deck;
    }
    
    // ==================== 訊息顯示函數 ====================
    /**
     * 顯示訊息
     * @param {string} text - 訊息內容
     * @param {number} duration - 顯示持續時間(毫秒)
     */
    function showMessage(text, duration = 2000) {
        const messageEl = document.getElementById('message');
        messageEl.textContent = text;
        messageEl.style.display = 'block';
        setTimeout(() => {
            messageEl.style.display = 'none';
        }, duration);
    }
    
    // ==================== 提示系統函數 ====================
    /**
     * 顯示遊戲提示
     */
    function showHint() {
        if (isAnimating) return; // 動畫中不顯示提示
        const hintBtn = document.getElementById('hint-btn');
        hintBtn.disabled = true; // 禁用提示按鈕
        
        // 清除現有高光效果
        document.querySelectorAll('.highlight, .target-highlight').forEach(el => {
            el.classList.remove('highlight', 'target-highlight');
        });
        
        let hint = null;
        
        // 1. 尋找Ace移動
        hint = findAceMove();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        // 2. 尋找花色區移動
        hint = findFoundationMove();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        // 3. 根據翻開牌數量尋找最佳表格移動
        hint = findBestTableauMoveByUncoveredCards();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        // 4. 根據連鎖長度尋找最佳表格移動
        hint = findBestTableauMoveByChainLength();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCardPair(hint.sourceCardId, hint.targetType, hint.targetIdx, hint.targetCardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        // 5. 檢查廢牌區移動
        if (state.waste.length > 0) {
            const wasteCard = state.waste[state.waste.length - 1];
            for (let j = 0; j < 4; j++) {
                const foundation = state.foundations[j];
                if (canMoveToFoundation(wasteCard, foundation)) {
                    showMessage(`提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到花色區${j+1}`, 2000);
                    let targetCardId = null;
                    if (foundation.length > 0) {
                        targetCardId = foundation[foundation.length - 1].id;
                    }
                    highlightCardPair(wasteCard.id, 'foundation', j, targetCardId);
                    setTimeout(() => { hintBtn.disabled = false; }, 500);
                    return;
                }
            }
            for (let targetCol = 0; targetCol < 7; targetCol++) {
                const targetPile = state.tableau[targetCol];
                if (canMoveToTableau(wasteCard, targetPile)) {
                    showMessage(`提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到第${targetCol+1}列`, 2000);
                    let targetCardId = null;
                    if (targetPile.length > 0) {
                        targetCardId = targetPile[targetPile.length - 1].id;
                    }
                    highlightCardPair(wasteCard.id, 'tableau', targetCol, targetCardId);
                    setTimeout(() => { hintBtn.disabled = false; }, 500);
                    return;
                }
            }
        }
        
        // 6. 尋找可翻開的牌
        hint = findFlipCardHint();
        if (hint) {
            showMessage(hint.message, 2000);
            highlightCard(hint.cardId);
            setTimeout(() => { hintBtn.disabled = false; }, 500);
            return;
        }
        
        // 7. 預設提示
        if (state.stock.length > 0) {
            showMessage("提示：點擊牌堆來翻開新牌", 2000);
            highlightStock();
        } else if (state.waste.length > 0) {
            showMessage("提示：點擊廢牌堆左側的箭頭重新使用廢牌", 2000);
            highlightStock();
        } else {
            showMessage("嘗試移動不同的牌，或者重新開始遊戲", 2000);
        }
        
        setTimeout(() => { hintBtn.disabled = false; }, 500);
    }
    
    /**
     * 尋找Ace移動
     * @returns {Object|null} - 提示物件或null
     */
    function findAceMove() {
        // 檢查表格中的Ace
        for (let i = 0; i < 7; i++) {
            const pile = state.tableau[i];
            if (pile.length === 0) continue;
            const topCard = pile[pile.length - 1];
            if (!topCard.faceUp) continue;
            if (topCard.rank === 1) {
                let alreadyInFoundation = false;
                // 檢查是否已在花色區
                for (let j = 0; j < 4; j++) {
                    const foundation = state.foundations[j];
                    if (foundation.length > 0 && foundation[0].suit === topCard.suit) {
                        alreadyInFoundation = true;
                        break;
                    }
                }
                if (!alreadyInFoundation) {
                    return {
                        message: `提示：將第${i+1}列的${topCard.text}${topCard.suit}移到花色區`,
                        sourceCardId: topCard.id,
                        targetType: 'foundation',
                        targetIdx: getEmptyFoundationIndex(),
                        targetCardId: null
                    };
                }
            }
        }
        // 檢查廢牌區中的Ace
        if (state.waste.length > 0) {
            const wasteCard = state.waste[state.waste.length - 1];
            if (wasteCard.rank === 1) {
                let alreadyInFoundation = false;
                for (let j = 0; j < 4; j++) {
                    const foundation = state.foundations[j];
                    if (foundation.length > 0 && foundation[0].suit === wasteCard.suit) {
                        alreadyInFoundation = true;
                        break;
                    }
                }
                if (!alreadyInFoundation) {
                    return {
                        message: `提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到花色區`,
                        sourceCardId: wasteCard.id,
                        targetType: 'foundation',
                        targetIdx: getEmptyFoundationIndex(),
                        targetCardId: null
                    };
                }
            }
        }
        return null;
    }
    
    /**
     * 取得空的花色區索引
     * @returns {number} - 花色區索引
     */
    function getEmptyFoundationIndex() {
        for (let i = 0; i < 4; i++) {
            if (state.foundations[i].length === 0) return i;
        }
        return 0;
    }
    
    /**
     * 尋找花色區移動
     * @returns {Object|null} - 提示物件或null
     */
    function findFoundationMove() {
        // 檢查表格中的牌
        for (let i = 0; i < 7; i++) {
            const pile = state.tableau[i];
            if (pile.length === 0) continue;
            const topCard = pile[pile.length - 1];
            if (!topCard.faceUp) continue;
            for (let j = 0; j < 4; j++) {
                const foundation = state.foundations[j];
                if (canMoveToFoundation(topCard, foundation)) {
                    let targetCardId = null;
                    if (foundation.length > 0) targetCardId = foundation[foundation.length - 1].id;
                    return {
                        message: `提示：將第${i+1}列的${topCard.text}${topCard.suit}移到花色區${j+1}`,
                        sourceCardId: topCard.id,
                        targetType: 'foundation',
                        targetIdx: j,
                        targetCardId: targetCardId
                    };
                }
            }
        }
        // 檢查廢牌區的牌
        if (state.waste.length > 0) {
            const wasteCard = state.waste[state.waste.length - 1];
            for (let j = 0; j < 4; j++) {
                const foundation = state.foundations[j];
                if (canMoveToFoundation(wasteCard, foundation)) {
                    let targetCardId = null;
                    if (foundation.length > 0) targetCardId = foundation[foundation.length - 1].id;
                    return {
                        message: `提示：將廢牌區的${wasteCard.text}${wasteCard.suit}移到花色區${j+1}`,
                        sourceCardId: wasteCard.id,
                        targetType: 'foundation',
                        targetIdx: j,
                        targetCardId: targetCardId
                    };
                }
            }
        }
        return null;
    }
    
    /**
     * 根據翻開牌數量尋找最佳表格移動
     * @returns {Object|null} - 提示物件或null
     */
    function findBestTableauMoveByUncoveredCards() {
        let bestMove = null;
        let bestUncoveredCount = -1;
        for (let sourceCol = 0; sourceCol < 7; sourceCol++) {
            const sourcePile = state.tableau[sourceCol];
            if (sourcePile.length === 0) continue;
            let sourceIdx = -1;
            // 尋找最上面翻開的牌
            for (let i = sourcePile.length - 1; i >= 0; i--) {
                if (sourcePile[i].faceUp) {
                    sourceIdx = i;
                    break;
                }
            }
            if (sourceIdx === -1) continue;
            const card = sourcePile[sourceIdx];
            // 檢查所有目標列
            for (let targetCol = 0; targetCol < 7; targetCol++) {
                if (sourceCol === targetCol) continue;
                const targetPile = state.tableau[targetCol];
                if (canMoveToTableau(card, targetPile)) {
                    // 計算移動後會翻開多少張牌
                    let uncoveredCount = 0;
                    if (sourceIdx > 0 && !sourcePile[sourceIdx - 1].faceUp) uncoveredCount = 1;
                    // 選擇翻開最多牌的移動
                    if (uncoveredCount > bestUncoveredCount) {
                        bestUncoveredCount = uncoveredCount;
                        let targetCardId = null;
                        if (targetPile.length > 0) targetCardId = targetPile[targetPile.length - 1].id;
                        bestMove = {
                            sourceCol, targetCol, card,
                            message: `提示：將第${sourceCol+1}列的${card.text}${card.suit}移到第${targetCol+1}列`,
                            sourceCardId: card.id,
                            targetType: 'tableau',
                            targetIdx: targetCol,
                            targetCardId: targetCardId
                        };
                    }
                }
            }
        }
        return bestMove;
    }
    
    /**
     * 根據連鎖長度尋找最佳表格移動
     * @returns {Object|null} - 提示物件或null
     */
    function findBestTableauMoveByChainLength() {
        let bestMove = null;
        let bestChainLength = -1;
        for (let sourceCol = 0; sourceCol < 7; sourceCol++) {
            const sourcePile = state.tableau[sourceCol];
            if (sourcePile.length === 0) continue;
            let sourceIdx = -1;
            // 尋找最上面翻開的牌
            for (let i = sourcePile.length - 1; i >= 0; i--) {
                if (sourcePile[i].faceUp) {
                    sourceIdx = i;
                    break;
                }
            }
            if (sourceIdx === -1) continue;
            const card = sourcePile[sourceIdx];
            const chainLength = sourcePile.length - sourceIdx; // 計算連鎖長度
            // 檢查所有目標列
            for (let targetCol = 0; targetCol < 7; targetCol++) {
                if (sourceCol === targetCol) continue;
                const targetPile = state.tableau[targetCol];
                if (canMoveToTableau(card, targetPile)) {
                    // 選擇最長連鎖的移動
                    if (chainLength > bestChainLength) {
                        bestChainLength = chainLength;
                        let targetCardId = null;
                        if (targetPile.length > 0) targetCardId = targetPile[targetPile.length - 1].id;
                        bestMove = {
                            sourceCol, targetCol, card,
                            message: `提示：將第${sourceCol+1}列的${card.text}${card.suit}移到第${targetCol+1}列`,
                            sourceCardId: card.id,
                            targetType: 'tableau',
                            targetIdx: targetCol,
                            targetCardId: targetCardId
                        };
                    }
                }
            }
        }
        return bestMove;
    }
    
    /**
     * 尋找可翻開的牌
     * @returns {Object|null} - 提示物件或null
     */
    function findFlipCardHint() {
        for (let i = 0; i < 7; i++) {
            const pile = state.tableau[i];
            if (pile.length > 0) {
                const topCard = pile[pile.length - 1];
                if (!topCard.faceUp) {
                    return {
                        message: `提示：點擊第${i+1}列最上面的蓋牌來翻牌`,
                        cardId: topCard.id
                    };
                }
            }
        }
        return null;
    }
    
    /**
     * 高光顯示單張卡片
     * @param {string} cardId - 卡片ID
     */
    function highlightCard(cardId) {
        if (!cardId) return;
        const cardElement = document.querySelector(`[data-id="${cardId}"]`);
        if (cardElement) {
            cardElement.classList.add('highlight');
            setTimeout(() => { cardElement.classList.remove('highlight'); }, 2000);
        }
    }
    
    /**
     * 高光顯示卡片對（來源和目標）
     * @param {string} sourceCardId - 來源卡片ID
     * @param {string} targetType - 目標類型
     * @param {number} targetIdx - 目標索引
     * @param {string} targetCardId - 目標卡片ID
     */
    function highlightCardPair(sourceCardId, targetType, targetIdx, targetCardId = null) {
        // 高光源卡片
        const sourceElement = document.querySelector(`[data-id="${sourceCardId}"]`);
        if (sourceElement) {
            sourceElement.classList.add('highlight');
            setTimeout(() => { sourceElement.classList.remove('highlight'); }, 2000);
        }
        // 高光目標
        if (targetCardId) {
            const targetElement = document.querySelector(`[data-id="${targetCardId}"]`);
            if (targetElement) {
                targetElement.classList.add('target-highlight');
                setTimeout(() => { targetElement.classList.remove('target-highlight'); }, 2000);
            }
        } else if (targetType === 'foundation') {
            const foundationSlot = document.querySelector(`#slot-f${targetIdx}`);
            if (foundationSlot) {
                foundationSlot.classList.add('target-highlight');
                setTimeout(() => { foundationSlot.classList.remove('target-highlight'); }, 2000);
            }
        } else if (targetType === 'tableau') {
            const tableauSlot = document.querySelector(`#slot-t${targetIdx}`);
            if (tableauSlot) {
                tableauSlot.classList.add('target-highlight');
                setTimeout(() => { tableauSlot.classList.remove('target-highlight'); }, 2000);
            }
        }
    }
    
    /**
     * 高光顯示牌堆
     */
    function highlightStock() {
        const stockElement = document.querySelector('#slot-stock');
        if (stockElement) {
            stockElement.classList.add('highlight');
            setTimeout(() => { stockElement.classList.remove('highlight'); }, 2000);
        }
    }
    
    // ==================== 移動規則檢查函數 ====================
    /**
     * 檢查是否可以移動到花色區
     * @param {Object} card - 卡片物件
     * @param {Array} foundation - 花色區陣列
     * @returns {boolean} - 是否可以移動
     */
    function canMoveToFoundation(card, foundation) {
        if (foundation.length === 0) return card.rank === 1; // 空的花色區只能放Ace
        const topCard = foundation[foundation.length - 1]; // 花色區最上面的牌
        return card.suit === topCard.suit && card.rank === topCard.rank + 1; // 同花色且數字連續
    }
    
    /**
     * 檢查是否可以移動到表格
     * @param {Object} card - 卡片物件
     * @param {Array} tableauPile - 表格列陣列
     * @returns {boolean} - 是否可以移動
     */
    function canMoveToTableau(card, tableauPile) {
        if (tableauPile.length === 0) return card.rank === 13; // 空的表格列只能放King
        const topCard = tableauPile[tableauPile.length - 1]; // 表格列最上面的牌
        return card.color !== topCard.color && card.rank === topCard.rank - 1; // 不同顏色且數字連續
    }

    // ==================== 佈局計算函數 ====================
    let slotPositions = {}; // 槽位位置資訊
    let cardSize = {width: 0, height: 0}; // 卡片尺寸
    
    /**
     * 佈局所有槽位
     */
    function layoutSlots() {
        const board = document.getElementById('game-board');
        const w = board.clientWidth; // 遊戲區域寬度
        
        // 建立測量元素計算卡片尺寸
        const measure = document.createElement('div');
        measure.className = 'slot';
        board.appendChild(measure);
        cardSize.width = measure.offsetWidth;
        cardSize.height = measure.offsetHeight;
        board.removeChild(measure);

        // 檢查是否為手機版
        const isMobile = window.innerWidth < 600;
        if (isMobile) {
            // 限制手機上最大卡片尺寸
            const maxCardWidth = Math.min(cardSize.width, 75); // 從70增加到75
            const maxCardHeight = Math.min(cardSize.height, 105); // 從98增加到105
            cardSize.width = maxCardWidth;
            cardSize.height = maxCardHeight;
        }

        // 計算間距
        const gap = Math.max(0.5, (w - (cardSize.width * 7)) / 8); // 最小間距0.5px
        
        /**
         * 設定槽位位置
         * @param {string} id - 槽位ID
         * @param {number} x - X座標
         * @param {number} y - Y座標
         */
        const setPos = (id, x, y) => {
            const el = document.getElementById(id);
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            // 儲存位置資訊
            slotPositions[id] = { 
                left: x, top: y, right: x + cardSize.width, bottom: y + cardSize.height,
                cx: x + cardSize.width/2, cy: y + cardSize.height/2
            };
        };

        // 上方區域佈局
        const topRowY = 10;
        setPos('slot-stock', gap, topRowY); // 牌堆
        setPos('slot-waste', gap*2 + cardSize.width, topRowY); // 廢牌堆
        
        // 四個花色區從右到左排列
        for(let i=0; i<4; i++) {
            setPos(`slot-f${i}`, w - gap*(4-i) - cardSize.width*(4-i), topRowY);
        }
        
        // 下方七列表格佈局
        const tableauY = topRowY + cardSize.height + (isMobile ? 10 : 30); // 手機上減少間距
        for(let i=0; i<7; i++) {
            let x = gap * (i+1) + cardSize.width * i;
            setPos(`slot-t${i}`, x, tableauY);
        }
    }

    // ==================== 渲染引擎函數 ====================
    /**
     * 渲染遊戲畫面
     */
    function render() {
        const layer = document.getElementById('card-layer');
        layer.innerHTML = ''; // 清空圖層

        /**
         * 繪製單張卡片
         * @param {Object} card - 卡片物件
         * @param {number} x - X座標
         * @param {number} y - Y座標
         * @param {string} type - 卡片類型
         * @param {number} pileIdx - 所在堆疊索引
         * @param {number} cardIdx - 卡片在堆疊中的索引
         */
        const drawCard = (card, x, y, type, pileIdx, cardIdx) => {
            const div = document.createElement('div');
            div.className = `card ${card.faceUp ? '' : 'back'}`;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.dataset.id = card.id;
            div.dataset.type = type;
            div.dataset.pileIdx = pileIdx;
            div.dataset.cardIdx = cardIdx;

            if (card.faceUp) {
                div.classList.add(card.color);
                div.innerHTML = `
                    <div class="card-face">
                        <div class="card-num ${card.color}">${card.text}</div>
                        <div class="card-suit-top ${card.color}">${card.suit}</div>
                        <div class="card-center-suit ${card.color}">${card.suit}</div>
                    </div>
                `;
                
                // 添加拖曳事件監聽器
                div.addEventListener('mousedown', (e) => startDrag(e, type, pileIdx, cardIdx));
                div.addEventListener('touchstart', (e) => startDrag(e, type, pileIdx, cardIdx), {passive: false});
                
            } else {
                // 背面朝上的卡片添加點擊事件
                if (type === 'stock') {
                    div.addEventListener('click', drawStock);
                } else if (type === 'tableau') {
                    const pile = state.tableau[pileIdx];
                    if (cardIdx === pile.length - 1) {
                        div.addEventListener('click', () => flipTableauCard(pileIdx));
                    }
                }
            }
            layer.appendChild(div);
        };

        // 繪製牌堆
        const sPos = slotPositions['slot-stock'];
        if (state.stock.length > 0) {
            drawCard(state.stock[state.stock.length-1], sPos.left, sPos.top, 'stock', 0, 0);
        } else {
            // 牌堆為空時顯示重新整理按鈕
            const emptyStock = document.createElement('div');
            emptyStock.style.cssText = `position:absolute; left:${sPos.left}px; top:${sPos.top}px; width:${cardSize.width}px; height:${cardSize.height}px;`;
            emptyStock.innerHTML = '<div class="refresh-btn">↺</div>';
            emptyStock.addEventListener('click', resetStock);
            layer.appendChild(emptyStock);
        }

        // 繪製廢牌堆
        const wPos = slotPositions['slot-waste'];
        const wasteLen = state.waste.length;
        if (wasteLen > 0) {
            const topWasteCard = state.waste[wasteLen - 1];
            drawCard(topWasteCard, wPos.left, wPos.top, 'waste', 0, wasteLen - 1);
        }

        // 繪製四個花色區
        for(let i=0; i<4; i++) {
            const pos = slotPositions[`slot-f${i}`];
            const pile = state.foundations[i];
            if (pile.length > 0) {
                drawCard(pile[pile.length-1], pos.left, pos.top, 'foundation', i, pile.length-1);
            }
        }

        // 繪製七列表格
        for(let i=0; i<7; i++) {
            const pos = slotPositions[`slot-t${i}`];
            const pile = state.tableau[i];
            let currentOffset = 0; // 當前偏移量
            pile.forEach((card, idx) => {
                if (idx > 0) {
                    const prevCard = pile[idx - 1];
                    // 計算重疊比例
                    let overlapRatio = prevCard.faceUp ? (card.faceUp ? 0.7 : 0.9) : 0.9;
                    // 修改：手機版翻開的牌重疊50%
                    const isMobile = window.innerWidth < 600;
                    if (isMobile && card.faceUp) {
                        overlapRatio = 0.5; // 修改：改為50%重疊 (從0.65減少)
                    }
                    currentOffset += cardSize.height * (1 - overlapRatio); // 計算偏移量
                }
                drawCard(card, pos.left, pos.top + currentOffset, 'tableau', i, idx);
            });
        }
    }
    
    /**
     * 翻開表格中的卡片
     * @param {number} pileIdx - 表格列索引
     */
    function flipTableauCard(pileIdx) {
        if (isAnimating) return;
        const pile = state.tableau[pileIdx];
        if (pile.length > 0) {
            const topCard = pile[pile.length - 1];
            if (!topCard.faceUp) {
                topCard.faceUp = true; // 翻開卡片
                state.moves++; // 增加移動次數
                saveStateToHistory(); // 儲存狀態
                render(); // 重新渲染
                updateTimer(); // 更新計時器
                updateScore(); // 更新分數
            }
        }
    }

    /**
     * 從牌堆抽牌
     */
    function drawStock() {
        if (isAnimating) return;
        if (state.stock.length === 0) return;
        const card = state.stock.pop(); // 從牌堆取牌
        card.faceUp = true; // 翻開卡片
        state.waste.push(card); // 放入廢牌堆
        state.moves++; // 增加移動次數
        saveStateToHistory(); // 儲存狀態
        render(); // 重新渲染
        updateTimer(); // 更新計時器
        updateScore(); // 更新分數
    }

    /**
     * 重置牌堆（將廢牌堆放回牌堆）
     */
    function resetStock() {
        if (isAnimating) return;
        if (state.waste.length === 0) return;
        state.stock = state.waste.reverse().map(c => { 
            c.faceUp = false; // 將牌面朝下
            return c; 
        });
        state.waste = []; // 清空廢牌堆
        state.moves++; // 增加移動次數
        saveStateToHistory(); // 儲存狀態
        render(); // 重新渲染
        updateTimer(); // 更新計時器
        updateScore(); // 更新分數
    }

    // ==================== 自動移動動畫函數 ====================
    /**
     * 執行卡片移動動畫
     * @param {Array} cards - 要移動的卡片陣列
     * @param {Object} sourceRect - 來源位置矩形
     * @param {Object} targetRect - 目標位置矩形
     * @param {Function} onComplete - 動畫完成後的回呼函數
     */
    function animateMove(cards, sourceRect, targetRect, onComplete) {
        isAnimating = true; // 標記動畫開始
        const ghosts = []; // 幽靈卡片陣列
        
        // 建立幽靈卡片
        cards.forEach((card, i) => {
            const ghost = document.createElement('div');
            ghost.className = `card flying-card ${card.color}`;
            ghost.innerHTML = `
                <div class="card-face">
                    <div class="card-num ${card.color}">${card.text}</div>
                    <div class="card-suit-top ${card.color}">${card.suit}</div>
                    <div class="card-center-suit ${card.color}">${card.suit}</div>
                </div>
            `;
            
            // 計算堆疊偏移量
            const overlapRatio = 0.7;
            const overlapHeight = cardSize.height * overlapRatio;
            const offset = i * (cardSize.height - overlapHeight);

            // 設定初始位置
            ghost.style.left = sourceRect.left + 'px';
            ghost.style.top = (sourceRect.top + offset) + 'px';
            ghost.style.width = cardSize.width + 'px';
            ghost.style.height = cardSize.height + 'px';
            
            document.body.appendChild(ghost);
            ghosts.push(ghost);
        });

        // 強制瀏覽器 Reflow 以確保動畫發生
        void ghosts[0].offsetWidth;

        // 設定目標位置
        ghosts.forEach((ghost, i) => {
            const overlapRatio = 0.7; // 保持一致
            const overlapHeight = cardSize.height * overlapRatio;
            const offset = i * (cardSize.height - overlapHeight);
            
            ghost.style.left = targetRect.left + 'px';
            ghost.style.top = (targetRect.top + offset) + 'px';
        });

        // 動畫結束後清理
        setTimeout(() => {
            ghosts.forEach(g => g.remove()); // 移除幽靈卡片
            isAnimating = false; // 標記動畫結束
            if (onComplete) onComplete(); // 執行回呼函數
        }, 300); // 配合 CSS transition 0.3s
    }

    // ==================== 雙擊自動移動邏輯 ====================
    /**
     * 處理雙擊事件
     * @param {string} type - 卡片類型
     * @param {number} pileIdx - 堆疊索引
     * @param {number} cardIdx - 卡片索引
     * @param {string} cardId - 卡片ID
     */
    function handleDoubleClick(type, pileIdx, cardIdx, cardId) {
        if (type === 'foundation') return; // 花色區的牌不能雙擊移動
        if (isAnimating) return; // 動畫中禁止操作
        
        let sourcePile;
        let card;
        
        // 根據卡片類型取得來源堆疊和卡片
        if (type === 'tableau') {
            sourcePile = state.tableau[pileIdx];
            if (cardIdx < 0 || cardIdx >= sourcePile.length) return;
            card = sourcePile[cardIdx];
            
            if (!card.faceUp) return; // 背面朝上的牌不能移動
            // 檢查卡片上方是否有未翻開的牌
            for (let i = cardIdx + 1; i < sourcePile.length; i++) {
                if (!sourcePile[i].faceUp) {
                    shakeCard(cardId); // 震動提示
                    return;
                }
            }
        } else if (type === 'waste') {
            sourcePile = state.waste;
            if (cardIdx !== sourcePile.length - 1) return; // 只能移動最上面的牌
            card = sourcePile[cardIdx];
        } else {
            return;
        }

        // 取得來源位置 (用於動畫)
        const cardEl = document.querySelector(`[data-id="${cardId}"]`);
        if (!cardEl) return;
        const sourceRect = cardEl.getBoundingClientRect();
        
        // 1. 嘗試移動到花色區
        for (let i = 0; i < 4; i++) {
            const foundation = state.foundations[i];
            if (canMoveToFoundation(card, foundation)) {
                // 取得目標位置
                const targetEl = document.getElementById(`slot-f${i}`);
                const targetRect = targetEl.getBoundingClientRect();
                
                // 準備移動數據
                const cardsToMove = (type === 'tableau') ? sourcePile.slice(cardIdx) : [sourcePile[sourcePile.length-1]];

                // 播放動畫
                animateMove(cardsToMove, sourceRect, targetRect, () => {
                    // 動畫結束後執行數據更新
                    if (type === 'tableau') {
                        sourcePile.splice(cardIdx);
                        foundation.push(...cardsToMove);
                        if (sourcePile.length > 0) sourcePile[sourcePile.length - 1].faceUp = true;
                    } else if (type === 'waste') {
                        foundation.push(sourcePile.pop());
                    }
                    
                    state.moves++;
                    saveStateToHistory();
                    render();
                    updateTimer();
                    updateScore(); // 更新分數
                    checkWin(); // 檢查是否獲勝
                });
                return; 
            }
        }
        
        // 2. 嘗試移動到表格
        for (let targetIdx = 0; targetIdx < 7; targetIdx++) {
            if (type === 'tableau' && targetIdx === pileIdx) continue;
            const targetPile = state.tableau[targetIdx];
            
            if (card.rank === 13 && targetPile.length === 0 && type === 'tableau' && cardIdx === 0) continue; 

            if (canMoveToTableau(card, targetPile)) {
                // 取得目標位置
                let targetRect;
                if (targetPile.length > 0) {
                    const topCardId = targetPile[targetPile.length-1].id;
                    const topCardEl = document.querySelector(`[data-id="${topCardId}"]`);
                    const rect = topCardEl.getBoundingClientRect();
                    targetRect = { 
                        left: rect.left, 
                        top: rect.top + (cardSize.height * 0.3) // 估算偏移量
                    };
                } else {
                    const slotEl = document.getElementById(`slot-t${targetIdx}`);
                    targetRect = slotEl.getBoundingClientRect();
                }

                const cardsToMove = (type === 'tableau') ? sourcePile.slice(cardIdx) : [sourcePile[sourcePile.length-1]];
                
                animateMove(cardsToMove, sourceRect, targetRect, () => {
                    if (type === 'tableau') {
                        sourcePile.splice(cardIdx);
                        targetPile.push(...cardsToMove);
                        if (sourcePile.length > 0) sourcePile[sourcePile.length - 1].faceUp = true;
                    } else if (type === 'waste') {
                        targetPile.push(sourcePile.pop());
                    }
                    
                    state.moves++;
                    saveStateToHistory();
                    render();
                    updateTimer();
                    updateScore(); // 更新分數
                    checkWin(); // 檢查是否獲勝
                });
                return;
            }
        }
        
        // 3. 失敗則震動
        shakeCard(cardId);
    }
    
    /**
     * 震動卡片效果
     * @param {string} cardId - 卡片ID
     */
    function shakeCard(cardId) {
        const cardElement = document.querySelector(`[data-id="${cardId}"]`);
        if (cardElement) {
            cardElement.classList.remove('shake');
            void cardElement.offsetWidth; // 強制重繪
            cardElement.classList.add('shake');
            setTimeout(() => { cardElement.classList.remove('shake'); }, 400);
        }
    }

    // ==================== 拖曳系統函數 ====================
    /**
     * 開始拖曳
     * @param {Event} e - 事件物件
     * @param {string} type - 卡片類型
     * @param {number} pileIdx - 堆疊索引
     * @param {number} cardIdx - 卡片索引
     */
    function startDrag(e, type, pileIdx, cardIdx) {
        if (isAnimating) return; // 動畫中禁止拖曳
        e.stopPropagation(); // 停止事件冒泡
        
        const now = Date.now(); // 當前時間
        
        // 根據類型取得來源堆疊
        let sourcePile = (type === 'tableau') ? state.tableau[pileIdx] : (type === 'waste' ? state.waste : []);
        if (type === 'foundation') sourcePile = state.foundations[pileIdx];
        const clickedCard = sourcePile[cardIdx];
        if (!clickedCard) return;

        // 雙擊檢測
        if (clickedCard.id === lastClickCardId && now - lastClickTime < 350) {
            handleDoubleClick(type, pileIdx, cardIdx, clickedCard.id);
            lastClickCardId = null;
            lastClickTime = 0;
            return;
        }
        
        lastClickCardId = clickedCard.id;
        lastClickTime = now;

        if (drag.isDragging || drag.pending) return; // 已在拖曳中

        if (!clickedCard.faceUp) return; // 背面朝上的牌不能拖曳
        if ((type === 'waste' || type === 'foundation') && cardIdx !== sourcePile.length - 1) return; // 只能拖曳最上面的牌
        
        drag.pending = true; // 標記為等待拖曳
        drag.isDragging = false;
        
        // 取得觸控/滑鼠座標
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        
        drag.startX = clientX;
        drag.startY = clientY;
        drag.origin = { type, pileIdx, cardIdx };
        
        // 設定要拖曳的卡片
        drag.cards = [];
        if (type === 'tableau') {
            // 表格中拖曳從點擊位置到最下面的所有牌
            for (let i = cardIdx; i < sourcePile.length; i++) {
                drag.cards.push(sourcePile[i]);
            }
        } else {
            // 廢牌堆和花色區只能拖曳一張牌
            drag.cards.push(clickedCard);
        }

        // 取得遊戲區域邊界
        const gameBoard = document.getElementById('game-board');
        drag.gameBoardRect = gameBoard.getBoundingClientRect();
        
        // 計算偏移量
        const cardEl = document.querySelector(`[data-id="${clickedCard.id}"]`);
        if (cardEl) {
            const rect = cardEl.getBoundingClientRect();
            drag.offset.x = clientX - rect.left;
            drag.offset.y = clientY - rect.top;
        }

        // 添加事件監聽器
        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    }

    /**
     * 建立拖曳時的幽靈卡片
     */
    function createGhosts() {
        if (!drag.cards.length) return;
        
        const startCardEl = document.querySelector(`[data-id="${drag.cards[0].id}"]`);
        if (!startCardEl) return;
        const rect = startCardEl.getBoundingClientRect();

        // 為每張拖曳中的卡片建立幽靈卡片
        drag.cards.forEach((card, i) => {
            const ghost = document.createElement('div');
            ghost.className = `card dragging-card ${card.color}`;
            ghost.innerHTML = `
                <div class="card-face">
                    <div class="card-num ${card.color}">${card.text}</div>
                    <div class="card-suit-top ${card.color}">${card.suit}</div>
                    <div class="card-center-suit ${card.color}">${card.suit}</div>
                </div>
            `;
            
            // 計算堆疊偏移量
            const overlapRatio = 0.7;
            const overlapHeight = cardSize.height * overlapRatio;
            const ghostOffset = i * (cardSize.height - overlapHeight);
            
            // 設定初始位置
            ghost.style.left = rect.left + 'px';
            ghost.style.top = (rect.top + ghostOffset) + 'px';
            ghost.style.width = rect.width + 'px';
            ghost.style.height = rect.height + 'px';
            
            document.body.appendChild(ghost);
            drag.elGhosts.push(ghost);
        });

        // 將原始卡片設為半透明
        drag.cards.forEach(card => {
            const el = document.querySelector(`[data-id="${card.id}"]`);
            if (el) el.style.opacity = '0.3';
        });
    }

    /**
     * 拖曳移動處理函數
     * @param {Event} e - 事件物件
     */
    function onDragMove(e) {
        if (!drag.pending && !drag.isDragging) return;
        
        // 取得觸控/滑鼠座標
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        
        // 檢查是否真正開始拖曳（移動距離超過5px）
        if (drag.pending) {
            const moveX = Math.abs(clientX - drag.startX);
            const moveY = Math.abs(clientY - drag.startY);
            
            if (moveX > 5 || moveY > 5) {
                drag.pending = false;
                drag.isDragging = true;
                createGhosts(); // 建立幽靈卡片
            } else {
                return;
            }
        }
        
        // 更新幽靈卡片位置
        if (drag.isDragging) {
            if (e.cancelable) e.preventDefault(); // 防止預設行為
            
            drag.elGhosts.forEach((el, i) => {
                const overlapRatio = 0.7;
                const overlapHeight = cardSize.height * overlapRatio;
                const ghostOffset = i * (cardSize.height - overlapHeight);
                el.style.left = (clientX - drag.offset.x) + 'px';
                el.style.top = (clientY - drag.offset.y + ghostOffset) + 'px';
            });
        }
    }

    /**
     * 拖曳結束處理函數
     * @param {Event} e - 事件物件
     */
    function onDragEnd(e) {
        // 移除事件監聽器
        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);

        // 處理等待拖曳狀態
        if (drag.pending) {
            drag.pending = false;
            return;
        }

        if (!drag.isDragging) return; // 未在拖曳中

        // 取得幽靈卡片位置
        const headGhost = drag.elGhosts[0];
        const ghostRect = headGhost.getBoundingClientRect();
        
        // 計算相對遊戲區域的位置
        const ghostLeftRelative = ghostRect.left - drag.gameBoardRect.left;
        const ghostTopRelative = ghostRect.top - drag.gameBoardRect.top;
        const ghostCenterX = ghostLeftRelative + ghostRect.width / 2;
        const ghostCenterY = ghostTopRelative + ghostRect.height / 2;

        let target = null; // 目標位置
        
        // 檢查是否拖曳到花色區
        for (let i = 0; i < 4; i++) {
            const s = slotPositions[`slot-f${i}`];
            if (!s) continue;
            if (ghostCenterX >= s.left && ghostCenterX <= s.right && 
                ghostCenterY >= s.top && ghostCenterY <= s.bottom + 50) {
                target = { type: 'foundation', idx: i };
                break;
            }
        }
        
        // 檢查是否拖曳到表格
        if (!target) {
            for (let i = 0; i < 7; i++) {
                const s = slotPositions[`slot-t${i}`];
                if (!s) continue;
                if (ghostCenterX >= s.left - 30 && ghostCenterX <= s.right + 30 && 
                    ghostCenterY >= s.top - 50) {
                    target = { type: 'tableau', idx: i };
                    break;
                }
            }
        }

        // 嘗試移動卡片
        let success = false;
        if (target) {
            success = tryMove(drag.cards, drag.origin, target);
        }

        // 清理幽靈卡片
        drag.elGhosts.forEach(el => el.remove());
        drag.elGhosts = [];
        drag.isDragging = false;
        
        // 恢復原始卡片透明度
        drag.cards.forEach(card => {
            const el = document.querySelector(`[data-id="${card.id}"]`);
            if (el) el.style.opacity = '1';
        });

        // 根據移動結果更新遊戲
        if (success) {
            state.moves++;
            saveStateToHistory();
            render();
            updateTimer();
            updateScore(); // 更新分數
            checkWin(); // 檢查是否獲勝
        } else {
            render(); // 移動失敗，重新渲染恢復原狀
        }
    }

    /**
     * 嘗試移動卡片
     * @param {Array} cards - 要移動的卡片陣列
     * @param {Object} source - 來源資訊
     * @param {Object} target - 目標資訊
     * @returns {boolean} - 移動是否成功
     */
    function tryMove(cards, source, target) {
        if (!cards || cards.length === 0) return false;
        const moveCard = cards[0]; // 移動的第一張卡片
        
        // 移動到花色區
        if (target.type === 'foundation') {
            if (cards.length > 1) return false; // 花色區只能移動一張牌
            const foundation = state.foundations[target.idx];
            if (foundation.length === 0) {
                if (moveCard.rank !== 1) return false; // 空的花色區只能放Ace
            } else {
                const topCard = foundation[foundation.length - 1];
                if (moveCard.suit !== topCard.suit || moveCard.rank !== topCard.rank + 1) return false; // 必須同花色且連續
            }
            performMove(source, target, cards); // 執行移動
            return true;
        }
        
        // 移動到表格
        if (target.type === 'tableau') {
            if (source.type === 'tableau' && source.pileIdx === target.idx) return false; // 不能移動到同一列
            const tableau = state.tableau[target.idx];
            if (tableau.length === 0) {
                if (moveCard.rank !== 13) return false; // 空的表格列只能放King
            } else {
                const topCard = tableau[tableau.length - 1];
                if (moveCard.color === topCard.color || moveCard.rank !== topCard.rank - 1) return false; // 必須不同顏色且連續
            }
            performMove(source, target, cards); // 執行移動
            return true;
        }
        return false;
    }

    /**
     * 執行移動操作
     * @param {Object} source - 來源資訊
     * @param {Object} target - 目標資訊
     * @param {Array} cards - 要移動的卡片陣列
     */
    function performMove(source, target, cards) {
        // 從來源移除卡片
        if (source.type === 'waste') {
            state.waste.splice(source.cardIdx, 1);
        } else if (source.type === 'tableau') {
            state.tableau[source.pileIdx].splice(source.cardIdx, cards.length);
            if (state.tableau[source.pileIdx].length > 0) {
                state.tableau[source.pileIdx][state.tableau[source.pileIdx].length - 1].faceUp = true; // 翻開下一張牌
            }
        } else if (source.type === 'foundation') {
            state.foundations[source.pileIdx].splice(source.cardIdx, 1);
        }
        
        // 添加到目標
        if (target.type === 'foundation') {
            state.foundations[target.idx].push(...cards);
        } else if (target.type === 'tableau') {
            state.tableau[target.idx].push(...cards);
        }
    }

    // ==================== 遊戲結束檢查 ====================
    /**
     * 檢查是否獲勝
     */
    function checkWin() {
        let totalCards = 0;
        state.foundations.forEach(pile => totalCards += pile.length); // 計算花色區總牌數
        if (totalCards === 52) { // 所有牌都在花色區
            stopTimer(); // 停止計時器
            updateScore(); // 計算最終分數
            setTimeout(() => {
                alert(`🎉 恭喜破關！ 🎉\n移動次數：${state.moves}\n最終分數：${state.score}`);
            }, 200);
        }
    }

    // ==================== 頁面載入和事件監聽 ====================
    window.addEventListener('load', () => {
        initGame('guaranteed'); // 初始化遊戲
        window.addEventListener('resize', layoutSlots); // 監聽視窗大小變化
    });
    
    // 防止手機雙指縮放
    document.addEventListener('gesturestart', function (e) {
        e.preventDefault();
    });
</script>
</body>
</html>